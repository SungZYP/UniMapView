/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import"../geometry.js";import{L as t}from"./Logger.js";import{k as e}from"./mathUtils.js";import{R as n,b as r,i as o}from"../core/lang.js";import{throwIfAborted as i}from"../core/promiseUtils.js";import{g as a}from"../geometry/SpatialReference.js";import l from"../geometry/Extent.js";const s=t.getLogger("esri.views.2d.engine.flow.dataUtils");async function c(t,e,r){const o=performance.now(),a=function(t,e){const n=function(t,e,n,r){if(0===r)return t;const o=Math.round(3*r),i=new Array(2*o+1);let a=0;for(let t=-o;t<=o;t++){const e=Math.exp(-t*t/(r*r));i[t+o]=e,a+=e}for(let t=-o;t<=o;t++)i[t+o]/=a;const l=new Float32Array(t.length);for(let r=0;r<n;r++)for(let n=0;n<e;n++){let a=0,s=0;for(let l=-o;l<=o;l++){if(n+l<0||n+l>=e)continue;const c=i[l+o];a+=c*t[2*(r*e+(n+l))+0],s+=c*t[2*(r*e+(n+l))+1]}l[2*(r*e+n)+0]=a,l[2*(r*e+n)+1]=s}const s=new Float32Array(t.length);for(let t=0;t<e;t++)for(let r=0;r<n;r++){let a=0,c=0;for(let s=-o;s<=o;s++){if(r+s<0||r+s>=n)continue;const h=i[s+o];a+=h*l[2*((r+s)*e+t)+0],c+=h*l[2*((r+s)*e+t)+1]}s[2*(r*e+t)+0]=a,s[2*(r*e+t)+1]=c}return s}(e.data,e.width,e.height,t.smoothing);if(t.interpolate){return(t,r)=>{const o=Math.floor(t),i=Math.floor(r);if(o<0||o>=e.width)return[0,0];if(i<0||i>=e.height)return[0,0];const a=t-o,l=r-i,s=o,c=i,h=o<e.width-1?o+1:o,f=i<e.height-1?i+1:i,u=n[2*(c*e.width+s)],d=n[2*(c*e.width+h)],m=n[2*(f*e.width+s)],w=n[2*(f*e.width+h)],g=n[2*(c*e.width+s)+1],p=n[2*(c*e.width+h)+1];return[(u*(1-l)+m*l)*(1-a)+(d*(1-l)+w*l)*a,(g*(1-l)+n[2*(f*e.width+s)+1]*l)*(1-a)+(p*(1-l)+n[2*(f*e.width+h)+1]*l)*a]}}return(t,r)=>{const o=Math.round(t),i=Math.round(r);return o<0||o>=e.width||i<0||i>=e.height?[0,0]:[n[2*(i*e.width+o)+0],n[2*(i*e.width+o)+1]]}}(t,e),l=performance.now(),c=function(t,e,r,o){const i=[],a=new n,l=1/Math.max(t.lineCollisionWidth,1),s=Math.round(r*l),c=Math.round(o*l),f=new Int32Array(s*c);for(let t=0;t<f.length;t++)f[t]=-1;const u=[];for(let e=0;e<o;e+=t.lineSpacing)for(let n=0;n<r;n+=t.lineSpacing)u.push({x:n,y:e,sort:a.getFloat()});u.sort(((t,e)=>t.sort-e.sort));for(const{x:n,y:r}of u)if(a.getFloat()<t.density){const o=h(t,e,n,r,i.length,f,s,c,l);if(o.length<2)continue;i.push(o)}return i}(t,a,e.width,e.height),f=performance.now(),u=function(t,e){const r=new n,o=t.reduce(((t,e)=>t+e.length),0),i=new Float32Array(4*o),a=new Array(t.length);let l=0,s=0;for(const n of t){const t=l;for(const t of n)i[4*l+0]=t.x,i[4*l+1]=t.y,i[4*l+2]=t.t,i[4*l+3]=t.speed,l++;a[s++]={startVertex:t,numberOfVertices:n.length,totalTime:n[n.length-1].t,timeSeed:e?r.getFloat():0}}return{lineVertices:i,lineDescriptors:a}}(c,!0),d=performance.now(),m=function(t,e=10){const{lineVertices:n,lineDescriptors:r}=t;let o=0,i=0;for(const t of r){o+=2*t.numberOfVertices;i+=6*(t.numberOfVertices-1)}const a=new Float32Array(9*o),l=new Uint32Array(i);let s=0,c=0;function h(){l[c++]=s-2,l[c++]=s,l[c++]=s-1,l[c++]=s,l[c++]=s+1,l[c++]=s-1}function f(t,e,n,r,o,i,l,c){const h=9*s;let f=0;a[h+f++]=t,a[h+f++]=e,a[h+f++]=1,a[h+f++]=n,a[h+f++]=i,a[h+f++]=l,a[h+f++]=r/2,a[h+f++]=o/2,a[h+f++]=c,s++,a[h+f++]=t,a[h+f++]=e,a[h+f++]=-1,a[h+f++]=n,a[h+f++]=i,a[h+f++]=l,a[h+f++]=-r/2,a[h+f++]=-o/2,a[h+f++]=c,s++}for(const t of r){const{totalTime:r,timeSeed:o}=t;let i=null,a=null,l=null,s=null,c=null,u=null;for(let d=0;d<t.numberOfVertices;d++){const m=n[4*(t.startVertex+d)+0],w=n[4*(t.startVertex+d)+1],g=n[4*(t.startVertex+d)+2],p=n[4*(t.startVertex+d)+3];let y=null,x=null,M=null,A=null;if(d>0){y=m-i,x=w-a;const t=Math.sqrt(y*y+x*x);if(y/=t,x/=t,d>1){let t=y+c,n=x+u;const r=Math.sqrt(t*t+n*n);t/=r,n/=r;const o=Math.min(1/(t*y+n*x),e);t*=o,n*=o,M=-n,A=t}else M=-x,A=y;null!==M&&null!==A&&(f(i,a,l,M,A,r,o,p),h())}i=m,a=w,l=g,c=y,u=x,s=p}f(i,a,l,-u,c,r,o,s)}return{vertexData:a,indexData:l}}(u),w=performance.now();if(t.profile){const t={"_createFlowFieldFromData()":Math.round(l-o),"_getStreamlines()":Math.round(f-l),"createAnimatedLinesData()":Math.round(d-f),"createLinesMesh()":Math.round(w-d),"Total elapsed time":Math.round(w-o)};s.info("createStreamlinesMesh profile",t)}return await Promise.resolve(),i(r),m}function h(t,e,n,r,o,i,a,l,s){const c=[];let h=n,f=r,u=0,[d,m]=e(h,f);d*=t.velocityScale,m*=t.velocityScale;const w=Math.sqrt(d*d+m*m);let g,p;c.push({x:h,y:f,t:u,speed:w});for(let n=0;n<t.verticesPerLine;n++){let[n,r]=e(h,f);n*=t.velocityScale,r*=t.velocityScale;const d=Math.sqrt(n*n+r*r);if(d<t.minSpeedThreshold)return c;const m=n/d,w=r/d;h+=m*t.segmentLength,f+=w*t.segmentLength;if(u+=t.segmentLength/d,Math.acos(m*g+w*p)>t.maxTurnAngle)return c;if(t.mergeLines){const t=Math.round(h*s),e=Math.round(f*s);if(t<0||t>a-1||e<0||e>l-1)return c;const n=i[e*a+t];if(-1!==n&&n!==o)return c;i[e*a+t]=o}c.push({x:h,y:f,t:u,speed:d}),g=m,p=w}return c}function f(t,n){const r=n.pixels,{width:o,height:i}=n,a=new Float32Array(o*i*2);if("vector-uv"===t)for(let t=0;t<o*i;t++)a[2*t+0]=r[0][t],a[2*t+1]=-r[1][t];else if("vector-magdir"===t)for(let t=0;t<o*i;t++){const n=r[0][t],o=e(r[1][t]),i=Math.cos(o-Math.PI/2),l=Math.sin(o-Math.PI/2);a[2*t+0]=i*n,a[2*t+1]=l*n}return{data:a,width:o,height:i}}async function u(t,e,n,r,o,i){const s=a(e.spatialReference);if(!s)return d(t,e,n,r,o,i);const[c,h]=s.valid,f=h-c,u=Math.ceil(e.width/f),m=e.width/u,w=Math.round(n/u);let g=e.xmin;const p=[];for(let n=0;n<u;n++){const n=new l({xmin:g,xmax:g+m,ymin:e.ymin,ymax:e.ymax,spatialReference:e.spatialReference});p.push(d(t,n,w,r,o,i)),g+=m}const y=await Promise.all(p),x={data:new Float32Array(n*r*2),width:n,height:r};let M=0;for(const t of y){for(let e=0;e<t.height;e++)for(let r=0;r<t.width;r++)M+r>=n||(x.data[2*(e*n+M+r)+0]=t.data[2*(e*t.width+r)+0],x.data[2*(e*n+M+r)+1]=t.data[2*(e*t.width+r)+1]);M+=t.width}return x}async function d(t,e,n,i,a,l){const s={requestProjectedLocalDirections:!0,signal:l};if(o(a)&&(s.timeExtent=a),"imagery"===t.type){await t.load({signal:l});const o=t.rasterInfo.dataType,a=await t.fetchImage(e,n,i,s);return!a||r(a.pixelData)||r(a.pixelData.pixelBlock)?{data:new Float32Array(n*i*2),width:n,height:i}:f(o,a.pixelData.pixelBlock)}await t.load({signal:l});const c=t.rasterInfo.dataType,h=await t.fetchPixels(e,n,i,s);return!h||r(h.pixelBlock)?{data:new Float32Array(n*i*2),width:n,height:i}:f(c,h.pixelBlock)}export{c,u as l};
