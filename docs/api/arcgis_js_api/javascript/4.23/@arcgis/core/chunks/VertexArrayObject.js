/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{i as e,z as t,A as s,B as i,b as r,p as n}from"../core/lang.js";import{L as a}from"./Logger.js";import{c as o}from"./Texture.js";import{C as c}from"./context-util.js";import{l as u,R as _,U as f,D as h,k as l,g as E,m as b,a as R}from"./enums.js";const A=a.getLogger("esri.views.webgl.BufferObject");class d{constructor(e,t,s,i){this._context=e,this.bufferType=t,this.usage=s,this._glName=null,this._size=-1,this._indexType=void 0,e.instanceCounter.increment(_.Buffer,this),this._glName=this._context.gl.createBuffer(),o(this._context.gl),i&&this.setData(i)}static createIndex(e,t,s){return new d(e,u.ELEMENT_ARRAY_BUFFER,t,s)}static createVertex(e,t,s){return new d(e,u.ARRAY_BUFFER,t,s)}static createUniform(e,t,s){if(e.type!==c.WEBGL2)throw new Error("Uniform buffers are supported in WebGL2 only!");return new d(e,u.UNIFORM_BUFFER,t,s)}static createPixelPack(e,t=f.STREAM_READ,s){if(e.type!==c.WEBGL2)throw new Error("Pixel pack buffers are supported in WebGL2 only!");const i=new d(e,u.PIXEL_PACK_BUFFER,t);return s&&i.setSize(s),i}static createPixelUnpack(e,t=f.STREAM_DRAW,s){if(e.type!==c.WEBGL2)throw new Error("Pixel unpack buffers are supported in WebGL2 only!");return new d(e,u.PIXEL_UNPACK_BUFFER,t,s)}get glName(){return this._glName}get size(){return this._size}get indexType(){return this._indexType}get byteSize(){return this.bufferType===u.ELEMENT_ARRAY_BUFFER?this._indexType===h.UNSIGNED_INT?4*this._size:2*this._size:this._size}get _isVAOAware(){return this.bufferType===u.ELEMENT_ARRAY_BUFFER||this.bufferType===u.ARRAY_BUFFER}dispose(){var e;if(null!=(e=this._context)&&e.gl){if(this._glName){this._context.gl.deleteBuffer(this._glName),this._glName=null}this._context.instanceCounter.decrement(_.Buffer,this),this._context=null}else this._glName&&A.warn("Leaked WebGL buffer object")}setSize(t,s=null){if(t<=0&&A.error("Buffer size needs to be positive!"),this.bufferType===u.ELEMENT_ARRAY_BUFFER&&e(s))switch(this._indexType=s,s){case h.UNSIGNED_SHORT:t*=2;break;case h.UNSIGNED_INT:t*=4}this._setBufferData(t)}setData(e){if(!e)return;let i=e.byteLength;this.bufferType===u.ELEMENT_ARRAY_BUFFER&&(t(e)&&(i/=2,this._indexType=h.UNSIGNED_SHORT),s(e)&&(i/=4,this._indexType=h.UNSIGNED_INT)),this._setBufferData(i,e)}_setBufferData(t,s=null){this._size=t;const i=this._context.getBoundVAO();this._isVAOAware&&this._context.bindVAO(null),this._context.bindBuffer(this);const r=this._context.gl;e(s)?r.bufferData(this.bufferType,s,this.usage):r.bufferData(this.bufferType,t,this.usage),o(r),this._isVAOAware&&this._context.bindVAO(i)}setSubData(e,i=0,r=0,n=e.byteLength){if(!e)return;(i<0||i>=this._size)&&A.error("offset is out of range!");let a=i,c=r,_=n,f=e.byteLength;this.bufferType===u.ELEMENT_ARRAY_BUFFER&&(t(e)?(f/=2,a*=2,c*=2,_*=2):s(e)&&(f/=4,a*=4,c*=4,_*=4)),void 0===n&&(n=f-1),r>=n&&A.error("end must be bigger than start!"),i+r-n>this._size&&A.error("An attempt to write beyond the end of the buffer!");const h=this._context.getBoundVAO();this._isVAOAware&&this._context.bindVAO(null),this._context.bindBuffer(this);const l=this._context.gl,E=ArrayBuffer.isView(e)?e.buffer:e,b=0===c&&_===e.byteLength?E:E.slice(c,_);l.bufferSubData(this.bufferType,a,b),o(l),this._isVAOAware&&this._context.bindVAO(h)}setSubDataFromView(e,t,s,i){if(!e)return;(t<0||t>=this._size)&&A.error("offset is out of range!"),s>=i&&A.error("end must be bigger than start!"),t+s-i>this._size&&A.error("An attempt to write beyond the end of the buffer!");const r=this._context.getBoundVAO();this._isVAOAware&&this._context.bindVAO(null),this._context.bindBuffer(this);const n=this._context.gl;if(this._context.type===c.WEBGL2)n.bufferSubData(this.bufferType,t*e.BYTES_PER_ELEMENT,e,s,i-s);else{const r=0===s&&i===e.length?e:e.subarray(s,i);n.bufferSubData(this.bufferType,t*e.BYTES_PER_ELEMENT,r)}o(n),this._isVAOAware&&this._context.bindVAO(r)}getSubData(e,t=0,s,r){if(this._context.type!==c.WEBGL2)return void A.error("Get buffer subdata is supported in WebGL2 only!");if(s<0||r<0)return void A.error("Problem getting subdata: offset and length were less than zero!");const n=i(e)?e.BYTES_PER_ELEMENT:1;if(n*((null!=s?s:0)+(null!=r?r:0))>e.byteLength)return void A.error("Problem getting subdata: offset and length exceeded destination size!");t+n*(null!=r?r:0)>this.byteSize&&A.warn("Potential problem getting subdata: requested data exceeds buffer size!");const a=this._context.gl;this._context.bindBuffer(this,u.COPY_READ_BUFFER),a.getBufferSubData(u.COPY_READ_BUFFER,t,e,s,r),this._context.unbindBuffer(u.COPY_READ_BUFFER)}async getSubDataAsync(e,t=0,s,i){this._context.type===c.WEBGL2?(await this._context.clientWaitAsync(),this.getSubData(e,t,s,i)):A.error("Get buffer subdata is supported in WebGL2 only!")}}function x(e){const t=e.gl;switch(t.getError()){case t.NO_ERROR:return null;case t.INVALID_ENUM:return"An unacceptable value has been specified for an enumerated argument";case t.INVALID_VALUE:return"A numeric argument is out of range";case t.INVALID_OPERATION:return"The specified command is not allowed for the current state";case t.INVALID_FRAMEBUFFER_OPERATION:return"The currently bound framebuffer is not framebuffer complete";case t.OUT_OF_MEMORY:return"Not enough memory is left to execute the command";case t.CONTEXT_LOST_WEBGL:return"WebGL context is lost"}return"Unknown error"}function B(e,t){return e.vertexBuffers[t].size/e.layout[t][0].stride}function g(e,t,s,i,r=0){const n=e.gl,a=e.capabilities.instancing;e.bindBuffer(s);for(const e of i){const s=t.get(e.name);void 0===s&&console.error(`There is no location for vertex attribute '${e.name}' defined.`);const i=r*e.stride;if(e.count<=4)n.vertexAttribPointer(s,e.count,e.type,e.normalized,e.stride,e.offset+i),n.enableVertexAttribArray(s),e.divisor>0&&a&&a.vertexAttribDivisor(s,e.divisor);else if(9===e.count)for(let t=0;t<3;t++)n.vertexAttribPointer(s+t,3,e.type,e.normalized,e.stride,e.offset+12*t+i),n.enableVertexAttribArray(s+t),e.divisor>0&&a&&a.vertexAttribDivisor(s+t,e.divisor);else if(16===e.count)for(let t=0;t<4;t++)n.vertexAttribPointer(s+t,4,e.type,e.normalized,e.stride,e.offset+16*t+i),n.enableVertexAttribArray(s+t),e.divisor>0&&a&&a.vertexAttribDivisor(s+t,e.divisor);else console.error("Unsupported vertex attribute element count: "+e.count)}}function T(e,t,s,i){const r=e.gl,n=e.capabilities.instancing;e.bindBuffer(s);for(const e of i){const s=t.get(e.name);if(e.count<=4)r.disableVertexAttribArray(s),e.divisor&&e.divisor>0&&n&&n.vertexAttribDivisor(s,0);else if(9===e.count)for(let t=0;t<3;t++)r.disableVertexAttribArray(s+t),e.divisor&&e.divisor>0&&n&&n.vertexAttribDivisor(s+t,0);else if(16===e.count)for(let t=0;t<4;t++)r.disableVertexAttribArray(s+t),e.divisor&&e.divisor>0&&n&&n.vertexAttribDivisor(s+t,0);else console.error("Unsupported vertex attribute element count: "+e.count)}e.unbindBuffer(u.ARRAY_BUFFER)}function G(e){switch(e){case R.ALPHA:case R.LUMINANCE:case R.RED:case R.RED_INTEGER:case E.R8:case E.R8I:case E.R8UI:case E.R8_SNORM:case b.STENCIL_INDEX8:return 1;case R.LUMINANCE_ALPHA:case R.RG:case R.RG_INTEGER:case E.RGBA4:case E.R16F:case E.R16I:case E.R16UI:case E.RG8:case E.RG8I:case E.RG8UI:case E.RG8_SNORM:case E.RGB565:case E.RGB5_A1:case b.DEPTH_COMPONENT16:return 2;case R.DEPTH_COMPONENT:case R.RGB:case R.RGB_INTEGER:case E.RGB8:case E.RGB8I:case E.RGB8UI:case E.RGB8_SNORM:case E.SRGB8:case b.DEPTH_COMPONENT24:return 3;case R.DEPTH_STENCIL:case R.RGBA:case R.RGBA_INTEGER:case E.RGBA8:case E.R32F:case E.R11F_G11F_B10F:case E.RG16F:case E.R32I:case E.R32UI:case E.RG16I:case E.RG16UI:case E.RGBA8I:case E.RGBA8UI:case E.RGBA8_SNORM:case E.SRGB8_ALPHA8:case E.RGB9_E5:case E.RGB10_A2UI:case E.RGB10_A2:case b.DEPTH_STENCIL:case b.DEPTH_COMPONENT32F:case b.DEPTH24_STENCIL8:return 4;case b.DEPTH32F_STENCIL8:return 5;case E.RGB16F:case E.RGB16I:case E.RGB16UI:return 6;case E.RG32F:case E.RG32I:case E.RG32UI:case E.RGBA16F:case E.RGBA16I:case E.RGBA16UI:return 8;case E.RGB32F:case E.RGB32I:case E.RGB32UI:return 12;case E.RGBA32F:case E.RGBA32I:case E.RGBA32UI:return 16;case l.COMPRESSED_RGB_S3TC_DXT1_EXT:case l.COMPRESSED_RGBA_S3TC_DXT1_EXT:return.5;case l.COMPRESSED_RGBA_S3TC_DXT3_EXT:case l.COMPRESSED_RGBA_S3TC_DXT5_EXT:return 1;case l.COMPRESSED_R11_EAC:case l.COMPRESSED_SIGNED_R11_EAC:case l.COMPRESSED_RGB8_ETC2:case l.COMPRESSED_SRGB8_ETC2:case l.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case l.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:return.5;case l.COMPRESSED_RG11_EAC:case l.COMPRESSED_SIGNED_RG11_EAC:case l.COMPRESSED_RGBA8_ETC2_EAC:case l.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return 1}return 0}function N(e){if(r(e))return 0;if("descriptor"in e)return e.glName?N(e.descriptor):0;const t=e.internalFormat||"pixelFormat"in e&&e.pixelFormat;if(!t)return 0;const s="hasMipmap"in e&&e.hasMipmap?1.3:1,i=e.width*e.height;return G(t)*i*s}const p=a.getLogger("esri.views.webgl.VertexArrayObject");class y{constructor(e,t,s,i,r=null){this._context=e,this._locations=t,this._layout=s,this._buffers=i,this._indexBuffer=r,this._glName=null,this._initialized=!1,e.instanceCounter.increment(_.VAO,this)}get glName(){return this._glName}get vertexBuffers(){return this._buffers}get indexBuffer(){return this._indexBuffer}get size(){return Object.keys(this._buffers).reduce(((e,t)=>e+this._buffers[t].size),e(this._indexBuffer)?this._indexBuffer.size:0)}get layout(){return this._layout}get locations(){return this._locations}dispose(e=!0){if(!this._context)return void((this._glName||e&&Object.getOwnPropertyNames(this._buffers).length>0)&&p.warn("Leaked WebGL VAO"));if(this._glName){var t,s;const e=null==(t=this._context)||null==(s=t.capabilities)?void 0:s.vao;e?(e.deleteVertexArray(this._glName),this._glName=null):p.warn("Leaked WebGL VAO")}if(this._context.getBoundVAO()===this&&this._context.bindVAO(null),e){for(const e in this._buffers)this._buffers[e].dispose(),delete this._buffers[e];this._indexBuffer=n(this._indexBuffer)}this._context.instanceCounter.decrement(_.VAO,this),this._context=null}initialize(){if(this._initialized)return;const e=this._context.capabilities.vao;if(e){const t=e.createVertexArray();e.bindVertexArray(t),this._bindLayout(),e.bindVertexArray(null),this._glName=t}this._initialized=!0}bind(){this.initialize();const e=this._context.capabilities.vao;e?e.bindVertexArray(this.glName):(this._context.bindVAO(null),this._bindLayout())}_bindLayout(){const{_buffers:t,_layout:s,_indexBuffer:i}=this;t||p.error("Vertex buffer dictionary is empty!");const r=this._context.gl;for(const e in t){const i=t[e];i||p.error("Vertex buffer is uninitialized!");const r=s[e];r||p.error("Vertex element descriptor is empty!"),g(this._context,this._locations,i,r)}if(e(i)){!!this._context.capabilities.vao?r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,i.glName):this._context.bindBuffer(i)}}unbind(){this.initialize();const e=this._context.capabilities.vao;e?e.bindVertexArray(null):this._unbindLayout()}_unbindLayout(){const{_buffers:t,_layout:s}=this;t||p.error("Vertex buffer dictionary is empty!");for(const e in t){const i=t[e];i||p.error("Vertex buffer is uninitialized!");const r=s[e];T(this._context,this._locations,i,r)}e(this._indexBuffer)&&this._context.unbindBuffer(this._indexBuffer.bufferType)}}export{d as B,y as V,G as a,g as b,x as c,N as g,T as u,B as v};
