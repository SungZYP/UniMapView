/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import r from"../request.js";import{throwIfAborted as s}from"../core/promiseUtils.js";import{urlToObject as t}from"../core/urlUtils.js";import{V as o}from"./Version.js";import{property as a}from"../core/accessorSupport/decorators/property.js";import"../core/lang.js";import"./ensureType.js";import{r as i}from"./reader.js";import{subclass as l}from"../core/accessorSupport/decorators/subclass.js";import n from"../geometry/Extent.js";import p from"../geometry/SpatialReference.js";import{i as u,p as y}from"./commonProperties.js";import c from"../core/Collection.js";import{C as d}from"./CollectionFlattener.js";import b from"../core/Error.js";import{L as h}from"./Logger.js";import{g as m}from"./utils.js";import{a as f,n as S,c as E}from"../core/Accessor.js";import v from"../layers/support/Sublayer.js";import{i as g}from"./sublayerUtils.js";const x=c=>{let d=class extends c{constructor(){super(...arguments),this.capabilities=void 0,this.copyright=null,this.fullExtent=null,this.legendEnabled=!0,this.spatialReference=null,this.version=void 0}readCapabilities(e,r){var s,t;const a=r.capabilities&&r.capabilities.split(",").map((e=>e.toLowerCase().trim()));if(!a)return{operations:{supportsQuery:!1,supportsExportMap:!1,supportsExportTiles:!1,supportsTileMap:!1},exportMap:null,exportTiles:null};const i=this.type,l=a.includes("query"),n=a.includes("map"),p=!!r.exportTilesAllowed,u=a.includes("tilemap"),y="tile"!==i&&!!r.supportsDynamicLayers,c="tile"!==i&&(!r.tileInfo||y),d="tile"!==i&&(!r.tileInfo||y),b="tile"!==i,h=r.cimVersion&&o.parse(r.cimVersion),m=null!=(s=null==h?void 0:h.since(1,4))&&s,f=null!=(t=null==h?void 0:h.since(2,0))&&t;return{operations:{supportsQuery:l,supportsExportMap:n,supportsExportTiles:p,supportsTileMap:u},exportMap:n?{supportsArcadeExpressionForLabeling:m,supportsSublayersChanges:b,supportsDynamicLayers:y,supportsSublayerVisibility:c,supportsSublayerDefinitionExpression:d,supportsCIMSymbols:f}:null,exportTiles:p?{maxExportTilesCount:+r.maxExportTilesCount}:null}}readVersion(e,r){let s=r.currentVersion;return s||(s=r.hasOwnProperty("capabilities")||r.hasOwnProperty("tables")?10:r.hasOwnProperty("supportedImageFormatTypes")?9.31:9.3),s}async fetchSublayerInfo(e,r){return await this.fetchAllLayersAndTables(r),this._allLayersAndTablesMap.get(e)}async fetchAllLayersAndTables(e){await this.load(e),this._allLayersAndTablesPromise||(this._allLayersAndTablesPromise=r(t(this.url).path+"/layers",{responseType:"json",query:{f:"json",...this.customParameters,token:this.apiKey}}).then((e=>{this._allLayersAndTablesMap=new Map;for(const r of e.data.layers)this._allLayersAndTablesMap.set(r.id,r);return{result:e.data}}),(e=>({error:e}))));const o=await this._allLayersAndTablesPromise;if(s(e),"result"in o)return o.result;throw o.error}};return e([a({readOnly:!0})],d.prototype,"capabilities",void 0),e([i("service","capabilities",["capabilities","exportTilesAllowed","maxExportTilesCount","supportsDynamicLayers","tileInfo"])],d.prototype,"readCapabilities",null),e([a({json:{read:{source:"copyrightText"}}})],d.prototype,"copyright",void 0),e([a({type:n})],d.prototype,"fullExtent",void 0),e([a(u)],d.prototype,"id",void 0),e([a({type:Boolean,json:{origins:{service:{read:{enabled:!1}}},read:{source:"showLegend"},write:{target:"showLegend"}}})],d.prototype,"legendEnabled",void 0),e([a(y)],d.prototype,"popupEnabled",void 0),e([a({type:p})],d.prototype,"spatialReference",void 0),e([a({readOnly:!0})],d.prototype,"version",void 0),e([i("version",["currentVersion","capabilities","tables","supportedImageFormatTypes"])],d.prototype,"readVersion",null),d=e([l("esri.layers.mixins.ArcGISMapService")],d),d},L=h.getLogger("esri.layers.TileLayer");const T=c.ofType(v);function w(e,r){e&&e.forEach((e=>{r(e),e.sublayers&&e.sublayers.length&&w(e.sublayers,r)}))}const j=r=>{let s=class extends r{constructor(...e){super(...e),this.allSublayers=new d({getCollections:()=>[this.sublayers],getChildrenFunction:e=>e.sublayers}),this.sublayersSourceJSON={[f.SERVICE]:{},[f.PORTAL_ITEM]:{},[f.WEB_SCENE]:{},[f.WEB_MAP]:{}},this.handles.add(this.watch("sublayers",((e,r)=>this._handleSublayersChange(e,r)),!0))}readSublayers(e,r){if(!r||!e)return;const{sublayersSourceJSON:s}=this,t=S(r.origin);if(t<f.SERVICE)return;if(s[t]={context:r,visibleLayers:e.visibleLayers||s[t].visibleLayers,layers:e.layers||s[t].layers},t>f.SERVICE)return;this._set("serviceSublayers",this.createSublayersForOrigin("service").sublayers);const{sublayers:o,origin:a}=this.createSublayersForOrigin("web-document"),i=m(this);i.setDefaultOrigin(a),this._set("sublayers",new T(o)),i.setDefaultOrigin("user")}findSublayerById(e){return this.allSublayers.find((r=>r.id===e))}createServiceSublayers(){return this.createSublayersForOrigin("service").sublayers}createSublayersForOrigin(e){const r=S("web-document"===e?"web-map":e);let s=f.SERVICE,t=this.sublayersSourceJSON[f.SERVICE].layers,o=this.sublayersSourceJSON[f.SERVICE].context,a=null;const i=[f.PORTAL_ITEM,f.WEB_SCENE,f.WEB_MAP].filter((e=>e<=r));for(const e of i){const r=this.sublayersSourceJSON[e];g(r.layers)&&(s=e,t=r.layers,o=r.context,r.visibleLayers&&(a={visibleLayers:r.visibleLayers,context:r.context}))}const l=[f.PORTAL_ITEM,f.WEB_SCENE,f.WEB_MAP].filter((e=>e>s&&e<=r));let n=null;for(const e of l){const{layers:r,visibleLayers:s,context:t}=this.sublayersSourceJSON[e];r&&(n={layers:r,context:t}),s&&(a={visibleLayers:s,context:t})}const p=function(e,r){const s=[],t={};return e?(e.forEach((e=>{const o=new v;if(o.read(e,r),t[o.id]=o,null!=e.parentLayerId&&-1!==e.parentLayerId){const r=t[e.parentLayerId];r.sublayers||(r.sublayers=[]),r.sublayers.unshift(o)}else s.unshift(o)})),s):s}(t,o),u=new Map,y=new Set;if(n)for(const e of n.layers)u.set(e.id,e);if(a)for(const e of a.visibleLayers)y.add(e);return w(p,(e=>{n&&e.read(u.get(e.id),n.context),a&&e.read({defaultVisibility:y.has(e.id)},a.context)})),{origin:E(s),sublayers:new T({items:p})}}read(e,r){super.read(e,r),this.readSublayers(e,r)}_handleSublayersChange(e,r){r&&(r.forEach((e=>{e.parent=null,e.layer=null})),this.handles.remove("sublayers-owner")),e&&(e.forEach((e=>{e.parent=this,e.layer=this})),this.handles.add([e.on("after-add",(({item:e})=>{e.parent=this,e.layer=this})),e.on("after-remove",(({item:e})=>{e.parent=null,e.layer=null}))],"sublayers-owner"),"tile"===this.type&&this.handles.add(e.on("before-changes",(e=>{L.error(new b("tilelayer:sublayers-non-modifiable","ISublayer can't be added, moved, or removed from the layer's sublayers",{layer:this})),e.preventDefault()})),"sublayers-owner"))}};return e([a({readOnly:!0})],s.prototype,"allSublayers",void 0),e([a({readOnly:!0,type:c.ofType(v)})],s.prototype,"serviceSublayers",void 0),e([a({value:null,type:T,json:{read:!1,write:{allowNull:!0,ignoreOrigin:!0}}})],s.prototype,"sublayers",void 0),e([a({readOnly:!0})],s.prototype,"sublayersSourceJSON",void 0),s=e([l("esri.layers.mixins.SublayersOwner")],s),s};export{x as A,j as S};
