/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import"../geometry.js";import t from"../core/Accessor.js";import{b as r,i as s,P as n,c as i}from"../core/lang.js";import{L as o}from"./Logger.js";import{c as a,E as c,f as l,s as u}from"./mathUtils.js";import{v as p}from"./unitUtils.js";import{whenOnce as d}from"../core/watchUtils.js";import{property as f}from"../core/accessorSupport/decorators/property.js";import"./ensureType.js";import{subclass as y}from"../core/accessorSupport/decorators/subclass.js";import{WhereClause as h}from"../core/sql/WhereClause.js";import{projectBoundingSphere as g,load as m,project as E,projectVectorToVector as S}from"../geometry/projection.js";import{a as j,t as b}from"./aaBoundingBox.js";import{f as I,g as w,e as R,b as O,p as x}from"./aaBoundingRect.js";import{e as F}from"./Ellipsoid.js";import{project as v}from"../geometry/support/webMercatorUtils.js";import Q from"../layers/support/FeatureFilter.js";import{p as _,j as C,n as T}from"./I3SUtil.js";import D from"../geometry/SpatialReference.js";import N from"../core/Error.js";import A from"../core/Handles.js";import M from"../geometry/Extent.js";import{Q as G}from"./QueryEngine.js";import J from"../rest/support/FeatureSet.js";import V from"../rest/support/Query.js";import{g as B}from"./centroid.js";import{O as P}from"./OptimizedFeature.js";import{E as W}from"./Evented.js";import{c as k}from"./vec4f64.js";import{a as L}from"./I3SMeshView3D.js";const K=o.getLogger("esri.views.3d.layers.i3s.I3SMeshViewFilter");let U,q=class extends t{constructor(e){super(e),this._projectionEngineLoaded=!1}initialize(){d(this,"filter.geometry").then((()=>this.loadAsyncModule(async function(){if(U)return U;return U=await import("../geometry/geometryEngine.js"),U}().then((e=>{this.destroyed||(this._geometryEngine=e,this.applyFilters())})))))}get sortedObjectIds(){if(r(this.filter.objectIds))return null;const e=new Float64Array(this.filter.objectIds);return e.sort(),e}get parsedWhereClause(){const e=s(this.filter)?this.filter.where:null;if(r(e)||!e)return null;try{return h.create(e,this.layerFieldsIndex)}catch(e){K.error(`Failed to parse filter where clause: ${e}`)}return null}addFilters(e,t,r,n){const i=this.sortedObjectIds;s(i)&&e.push((e=>_(i,!0,e))),this.addSqlFilter(e,this.parsedWhereClause);const o=this.parsedGeometry;if(s(o)){const s=this.spatialRelationship;e.push(((e,i)=>function(e,t,r,s,n,i,o){const a=i[0].spatialReference||s.spatialReference;if(!g(t.node.mbs,n,H,a))return void K.warnOnce("SceneLayerView.filter.geometry is using unsupported SpatialReference, skipping geometry filter");const c=X(H,a),l=function(e,t,r,s,n){const i=t.renderSpatialReference,o=new Map,a={rings:[[[0,0,0],[0,0,0],[0,0,0],[0,0,0]]],hasZ:!1,hasM:!1,type:"polygon",spatialReference:r};a.rings[0][3]=a.rings[0][0];const c={indices:null,data:null,stride:0,startIndex:0,endIndex:0};let l,u;switch(e){case"intersects":l=(e,t)=>U.intersects(e,t)?z.KEEP:z.TEST,u=ee;break;case"contains":l=(e,t)=>U.contains(e,t)?z.TEST:z.DISCARD,u=ee;break;default:l=(e,t)=>U.disjoint(e,t)?z.TEST:z.DISCARD,u=te}return{collection:s,object:n,type:e,maskSR:r,renderSR:i,aabbCache:o,triangle:a,positions:c,triangleTest:l,geometryTest:u}}(o,s,a,r,t.objectHandle);for(const r of i){if(0===e.length)return;switch(Y(r,c,o)){case z.DISCARD:return void(e.length=0);case z.KEEP:continue}C(e,t.featureIds,(e=>re(r,e,l)))}}(e,i,n,t,r,o,s)))}}isMBSGeoemtryVisible(e,t,r){const n=this.parsedGeometry;if(s(n)){const s=this.spatialRelationship,i=n[0].spatialReference||t;if(!g(e,r,H,i))return K.warnOnce("SceneLayerView.filter.geometry is using unsupported SpatialReference, skipping geometry filter for MBS"),!0;return function(e,t,r,s){const n=X(e,r);return t.every((e=>Y(e,n,s)!==z.DISCARD))}(H,n,i,s)}return!0}get parsedGeometry(){if(r(this.filter))return null;if(!this._geometryEngine)return null;const{geometry:e}=this.filter;if(r(e))return null;const{distance:t,units:n}=this.filter,i=this.spatialRelationship,o="mesh"===e.type?e.extent:e;if(r(t)||0===t)return $(o,i);const a=n||p(o.spatialReference);if(o.spatialReference.isWGS84){return $(this._geometryEngine.geodesicBuffer(o,t,a),i)}const c=v(o,D.WGS84);if(s(c)){return $(v(this._geometryEngine.geodesicBuffer(c,t,a),o.spatialReference),i)}if(!this._projectionEngineLoaded&&(this.loadAsyncModule(m().then((()=>this._projectionEngineLoaded=!0))),!this._projectionEngineLoaded))return null;let l=null;try{l=E(o,D.WGS84)}catch(e){}if(l)try{l=E(this._geometryEngine.geodesicBuffer(l,t,a),o.spatialReference)}catch(e){l=null}return l||K.error(`Filter by geodesic buffer (distance) unsupported, failed to project input geometry (${o.spatialReference.wkid}) to WGS84.`),$(l,i)}get spatialRelationship(){return s(this.filter)?this.filter.spatialRelationship:"intersects"}static checkSupport(e){return e.timeExtent?(K.warn("Filters with a timeExtent are not supported for mesh scene layers"),!1):null!=(t=e.spatialRelationship)&&Z.indexOf(t)>=0||(K.warn(`Filters with spatialRelationship other than ${Z.join(", ")} are not supported for mesh scene layers`),!1);var t}};e([f({type:Q})],q.prototype,"filter",void 0),e([f()],q.prototype,"layerFieldsIndex",void 0),e([f()],q.prototype,"loadAsyncModule",void 0),e([f()],q.prototype,"applyFilters",void 0),e([f()],q.prototype,"addSqlFilter",void 0),e([f({readOnly:!0})],q.prototype,"sortedObjectIds",null),e([f({readOnly:!0})],q.prototype,"parsedWhereClause",null),e([f({readOnly:!0})],q.prototype,"parsedGeometry",null),e([f({readOnly:!0})],q.prototype,"spatialRelationship",null),e([f()],q.prototype,"_projectionEngineLoaded",void 0),e([f()],q.prototype,"_geometryEngine",void 0),q=e([y("esri.views.3d.layers.i3s.I3SMeshViewFilter")],q);const Z=["contains","intersects","disjoint"];var z;function $(e,t){if(r(e))return null;if("disjoint"===t&&"polygon"===e.type){const t=new Array(e.rings.length);for(let r=0;r<e.rings.length;++r){const s=I(1/0,1/0,-1/0,-1/0);w(s,e.rings[r]),t[r]={type:"polygon",rings:[e.rings[r]],spatialReference:e.spatialReference,aabr:s}}t.sort(((e,t)=>e.aabr[0]-t.aabr[0]));const r=new Set,s=new n;for(let e=0;e<t.length;++e){const n=t[e];for(let s=e+1;s<t.length;++s){const e=t[s];if(e.aabr[0]>=n.aabr[2])break;r.add(e)}r.forEach((e=>{if(n!==e)if(e.aabr[2]<=n.aabr[0])r.delete(e);else if(U.intersects(n,e)){n.rings=n.rings.concat(e.rings),R(n.aabr,e.aabr,n.aabr),delete n._geVersion,r.delete(e);const o=i(t,e,t.length,s);t.splice(o,1)}})),r.add(n)}for(const e of t)delete e.aabr;return t}return[e]}!function(e){e[e.KEEP=0]="KEEP",e[e.DISCARD=1]="DISCARD",e[e.TEST=2]="TEST"}(z||(z={}));const H=[0,0,0,0];function X(e,t){const r={x:e[0],y:e[1],hasZ:!1,hasM:!1,type:"point",spatialReference:t},s=!t.isWGS84&&!t.isWebMercator,n=Number.isNaN(e[3])?0:a(e[3],0,2*F.radius),i=s?U.buffer(r,n,1):U.geodesicBuffer(r,n,1);return i.type="polygon",i}function Y(e,t,r){switch(r){case"intersects":case"contains":return ee(e,t);case"disjoint":return te(e,t)}}function ee(e,t){return U.intersects(e,t)?U.contains(e,t)?z.KEEP:z.TEST:z.DISCARD}function te(e,t){return U.intersects(e,t)?U.contains(e,t)?z.DISCARD:z.TEST:z.KEEP}function re(e,t,r){const{collection:s,object:n,renderSR:i,maskSR:o,geometryTest:a,aabbCache:p}=r;let d=p.get(t);if(!d){const e=s.getObjectTransform(n);s.getComponentAabb(n,t,se);const r=[[se[0],se[1],0],[se[0],se[4],0],[se[3],se[4],0],[se[3],se[1],0]];for(let t=0;t<4;++t)c(r[t],r[t],e.rotationScale),l(r[t],r[t],e.position),S(r[t],i,r[t],o);d={rings:[r],hasZ:!1,hasM:!1,type:"polygon",spatialReference:o},d.rings[0][4]=d.rings[0][0],p.set(t,d)}switch(a(e,d)){case z.DISCARD:return!1;case z.KEEP:return!0}const{triangle:f,triangleTest:y,positions:h}=r,g=f.rings[0][0],m=f.rings[0][1],E=f.rings[0][2],j=s.getObjectTransform(n);s.getComponentPositions(n,t,h);const{indices:b,data:I,stride:w,startIndex:R,endIndex:O}=h;for(let t=R;t<O;t+=3){const r=w*b[t+0],s=w*b[t+1],n=w*b[t+2];u(g,I[r+0],I[r+1],I[r+2]),u(m,I[s+0],I[s+1],I[s+2]),u(E,I[n+0],I[n+1],I[n+2]),c(g,g,j.rotationScale),c(m,m,j.rotationScale),c(E,E,j.rotationScale),l(g,g,j.position),l(m,m,j.position),l(E,E,j.position),S(g,i,g,o),S(m,i,m,o),S(E,i,E,o);const a=m[0]-g[0],p=m[1]-g[1],d=E[0]-g[0],h=E[1]-g[1];if(!(Math.abs(a*h-p*d)<2.3283064365386963e-10))switch(delete f._geVersion,y(e,f)){case z.DISCARD:return!1;case z.KEEP:return!0}}return"intersects"!==r.type}const se=j(),ne=G;let ie=class extends t{constructor(e){super(e),this._dataQueryEngineInstance=null,this._handles=new A}get defaultQueryJSON(){return new V({outSpatialReference:this.spatialReference}).toJSON()}get dataQueryEngine(){return this._ensureDataQueryEngine()}initialize(){this._handles.add(this.layerView.on("visible-geometry-changed",(()=>this.spatialIndex.events.emit("changed"))))}destroy(){this._dataQueryEngineInstance&&(this._dataQueryEngineInstance.destroy(),this._dataQueryEngineInstance=null),this._handles&&(this._handles.destroy(),this._handles=null),this._set("layerView",null)}async executeQueryForCount(e,t){return this.dataQueryEngine.executeQueryForCount(this._ensureQueryJSON(e),t)}async executeQueryForExtent(e,t){const{count:r,extent:s}=await this.dataQueryEngine.executeQueryForExtent(this._ensureQueryJSON(e),t);return{count:r,extent:M.fromJSON(s)}}async executeQueryForIds(e,t){return this.dataQueryEngine.executeQueryForIds(this._ensureQueryJSON(e),t)}async executeQuery(e,t){const r=this._ensureQueryJSON(e);if(r.returnGeometry)throw new N("feature-store:unsupported-query","returnGeometry is not yet supported for mesh scene layer queries");if(r.returnCentroid)throw new N("feature-store:unsupported-query","returnCentroid is not yet supported for mesh scene layer queries");const s=await this.dataQueryEngine.executeQuery(r,t),n=J.fromJSON(s);return n.features.forEach((e=>{e.geometry=null})),n}_ensureQueryJSON(e){if(r(e))return this.defaultQueryJSON;const t=e.toJSON();return t.outSpatialReference||(e.outSpatialReference=this.spatialReference),t}_ensureDataQueryEngine(){if(this._dataQueryEngineInstance)return this._dataQueryEngineInstance;const e=this.layer.objectIdField||"OBJECTID",t=this.layer.fields.map((e=>e.toJSON())),r=this.layerView.view.resourceController.scheduler,s=this.spatialReference.toJSON(),n=this.priority,i=this.spatialIndex;return this._dataQueryEngineInstance=new ne({hasZ:!0,hasM:!1,geometryType:"esriGeometryPolygon",fields:t,timeInfo:null,spatialReference:s,objectIdField:e,featureStore:i,scheduler:r,priority:n}),this._dataQueryEngineInstance}};e([f({constructOnly:!0})],ie.prototype,"layerView",void 0),e([f({constructOnly:!0})],ie.prototype,"priority",void 0),e([f({constructOnly:!0})],ie.prototype,"spatialIndex",void 0),e([f({readOnly:!0,aliasOf:"layerView.view.spatialReference"})],ie.prototype,"spatialReference",void 0),e([f({readOnly:!0,aliasOf:"layerView.i3slayer"})],ie.prototype,"layer",void 0),e([f({readOnly:!0})],ie.prototype,"defaultQueryJSON",null),ie=e([y("esri.views.3d.layers.i3s.I3SQueryEngine")],ie);const oe=ie;class ae{constructor(e){this.objectIdField=e.objectIdField,this.getFeatureExtent=e.getFeatureExtent}getObjectId(e){return e.id}getAttributes(e){const{meta:t,index:r}=e,n={};this.objectIdField&&(n[this.objectIdField]=e.id);const i=s(t.attributeInfo)&&t.attributeInfo.attributeData;if(s(i))for(const e of Object.keys(i))n[e]=T(i[e],r);return n}getAttribute(e,t){if(t===this.objectIdField)return e.id;const{meta:r,index:n}=e,i=s(r.attributeInfo)&&r.attributeInfo.attributeData;return s(i)?T(i[t],n):null}getGeometry(e){if(e.geometry)return e.geometry;const[t,r,s,n,i]=this.getFeatureExtent(e,ce);return new P([5],[t,r,s,n,r,s,n,i,s,t,i,s,t,r,s])}getCentroid(e,t){if(e.geometry)return B(new P,e.geometry,t.hasZ,t.hasM);const[r,s,n,i,o,a]=this.getFeatureExtent(e,ce);return new P([0],[(r+i)/2,(s+o)/2,(n+a)/2])}cloneWithGeometry(e,t){const{id:r,index:s,meta:n}=e;return{id:r,index:s,meta:n,geometry:t}}}const ce=j();let le=class extends t{constructor(e){super(e),this.events=new W}forEach(e){this.forAllFeatures((t=>(e(t),L.CONTINUE)))}forEachBounds(e,t,r){const s=this.getFeatureExtent;for(const n of e)t(s(n,r))}forEachInBounds(e,t){this.forAllFeatures((r=>{const s=this.getFeatureExtent(r,pe);return x(e,b(s,de))&&t(r),L.CONTINUE}),(t=>{if(g(t.node.mbs,this.sourceSpatialReference,ue,this.viewSpatialReference),ue[0]>=e[0]&&ue[2]<=e[2]&&ue[1]>=e[1]&&ue[3]<=e[3])return L.CONTINUE;const r=Math.max(e[0],Math.min(ue[0],e[2])),s=Math.max(e[1],Math.min(ue[1],e[3])),n=ue[0]-r,i=ue[1]-s;return n*n+i*i<=ue[3]*ue[3]?L.CONTINUE:L.SKIP}))}};e([f({constructOnly:!0})],le.prototype,"featureAdapter",void 0),e([f({constructOnly:!0})],le.prototype,"forAllFeatures",void 0),e([f({constructOnly:!0})],le.prototype,"getFeatureExtent",void 0),e([f({constructOnly:!0})],le.prototype,"sourceSpatialReference",void 0),e([f({constructOnly:!0})],le.prototype,"viewSpatialReference",void 0),le=e([y("esri.views.3d.layers.i3s.I3SQueryFeatureStore")],le);const ue=k(),pe=j(),de=O(),fe=le;export{q as I,oe as a,fe as b,ae as c};
