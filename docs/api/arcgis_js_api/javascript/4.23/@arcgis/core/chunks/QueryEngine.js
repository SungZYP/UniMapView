/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import e from"../core/Error.js";import{r as t,x as s,clone as i,b as r,i as a,Y as n}from"../core/lang.js";import{a as u,b as o}from"./MemCache.js";import{g as c}from"./unitUtils.js";import{a as h,l,N as d,j as p}from"./aaBoundingBox.js";import{f as y,b as f}from"./aaBoundingRect.js";import{c as m}from"./extentUtils.js";import{fromJSON as x,isExtent as _,isPolygon as g}from"../geometry/support/jsonUtils.js";import{normalizeCentralMeridian as w}from"../geometry/support/normalizeUtils.js";import{e as S,j as Q}from"../geometry/SpatialReference.js";import{Q as R,S as F,v as I,a as E,b as j,h as b}from"./QueryEngineResult.js";import{p as k,c as A}from"./projectionSupport.js";import{q as z}from"./QueryEngineCapabilities.js";import{g as B,c as C,a as T}from"./spatialQuerySupport.js";import{c as O,b as v,n as G,Q as q}from"./utils17.js";import P from"../layers/support/FieldsIndex.js";import{l as M}from"./arcadeOnDemand.js";import{n as N}from"./Scheduler.js";const U="feature-store:unsupported-query",Z=new Set,H=new u(2e6);let D=0;class J{constructor(e){this.capabilities={query:z},this.geometryType=e.geometryType,this.hasM=e.hasM,this.hasZ=e.hasZ,this.objectIdField=e.objectIdField,this.spatialReference=e.spatialReference,this.definitionExpression=e.definitionExpression,this.featureStore=e.featureStore,this.aggregateAdapter=e.aggregateAdapter,this._changeHandle=this.featureStore.events.on("changed",(()=>this.clearCache())),this.timeInfo=e.timeInfo,e.cacheSpatialQueries&&(this._geometryQueryCache=new o(D+++"$$",H)),this.fieldsIndex=new P(e.fields),e.scheduler&&e.priority&&(this._frameTask=e.scheduler.registerTask(e.priority))}destroy(){this._frameTask=t(this._frameTask),this.clearCache(),s(this._geometryQueryCache),this._changeHandle=t(this._changeHandle),s(this.fieldsIndex)}get featureAdapter(){return this.featureStore.featureAdapter}get fullExtent(){const e=this.featureStore.fullBounds;return e?{xmin:e[0],ymin:e[1],xmax:e[2],ymax:e[3],spatialReference:O(this.spatialReference)}:null}get timeExtent(){return this.timeInfo?(this._timeExtent||(this._timeExtent=v(this.timeInfo,this.featureStore)),this._timeExtent):null}clearCache(){this._geometryQueryCache&&this._geometryQueryCache.clear(),this._allItems=null,this._timeExtent=null}async executeQuery(e={},t){let s,r=i(e);try{r=await this._schedule((()=>G(r,this.definitionExpression,this.spatialReference)),t),r=await this._reschedule((()=>this._checkQuerySupport(r)),t),s=await this._reschedule((()=>this._executeGeometryQuery(r,t)),t),s=await this._reschedule((()=>s.executeAggregateIdsQuery(r)),t),s=await this._reschedule((()=>s.executeObjectIdsQuery(r)),t),s=await this._reschedule((()=>s.executeTimeQuery(r)),t),s=await this._reschedule((()=>s.executeAttributesQuery(r)),t)}catch(e){if(e!==q)throw e;s=new R([],null,this)}return s.createQueryResponse(r)}async executeQueryForCount(e={},t){let s=i(e);s.returnGeometry=!1,s.returnCentroid=!1,s.outSR=null;try{s=await this._schedule((()=>G(s,this.definitionExpression,this.spatialReference)),t),s=await this._reschedule((()=>this._checkQuerySupport(s)),t);let e=await this._reschedule((()=>this._executeGeometryQuery(s,t)),t);return e=await this._reschedule((()=>e.executeAggregateIdsQuery(s)),t),e=await this._reschedule((()=>e.executeObjectIdsQuery(s)),t),e=await this._reschedule((()=>e.executeTimeQuery(s)),t),e=await this._reschedule((()=>e.executeAttributesQuery(s)),t),e.createQueryResponseForCount(s)}catch(e){if(e!==q)throw e;return 0}}async executeQueryForExtent(e={},t){let s,r=i(e);const a=r.outSR;try{r=await this._schedule((()=>G(r,this.definitionExpression,this.spatialReference)),t),r=await this._reschedule((()=>this._checkQuerySupport(r)),t),r.returnGeometry=!0,r.returnCentroid=!1,r.outSR=null,s=await this._reschedule((()=>this._executeGeometryQuery(r,t)),t),s=await this._reschedule((()=>s.executeAggregateIdsQuery(r)),t),s=await this._reschedule((()=>s.executeObjectIdsQuery(r)),t),s=await this._reschedule((()=>s.executeTimeQuery(r)),t),s=await this._reschedule((()=>s.executeAttributesQuery(r)),t);const e=s.size;if(!e)return{count:e,extent:null};l(V,d),this.featureStore.forEachBounds(s.items,(e=>p(V,e)),L);const i={xmin:V[0],ymin:V[1],xmax:V[3],ymax:V[4],spatialReference:O(this.spatialReference)};this.hasZ&&isFinite(V[2])&&isFinite(V[5])&&(i.zmin=V[2],i.zmax=V[5]);const n=k(i,s.spatialReference,a);if(n.spatialReference=O(a||this.spatialReference),n.xmax-n.xmin==0){const e=c(n.spatialReference);n.xmin-=e,n.xmax+=e}if(n.ymax-n.ymin==0){const e=c(n.spatialReference);n.ymin-=e,n.ymax+=e}if(this.hasZ&&null!=n.zmin&&null!=n.zmax&&n.zmax-n.zmin==0){const e=c(n.spatialReference);n.zmin-=e,n.zmax+=e}return{count:e,extent:n}}catch(e){if(e===q)return{count:0,extent:null};throw e}}async executeQueryForIds(e={},t){return this.executeQueryForIdSet(e,t).then((e=>Array.from(e)))}async executeQueryForIdSet(e={},t){let s,r=i(e);r.returnGeometry=!1,r.returnCentroid=!1,r.outSR=null;try{r=await this._schedule((()=>G(r,this.definitionExpression,this.spatialReference)),t),r=await this._reschedule((()=>this._checkQuerySupport(r)),t),s=await this._reschedule((()=>this._executeGeometryQuery(r,t)),t),s=await this._reschedule((()=>s.executeAggregateIdsQuery(r)),t),s=await this._reschedule((()=>s.executeObjectIdsQuery(r)),t),s=await this._reschedule((()=>s.executeTimeQuery(r)),t),s=await this._reschedule((()=>s.executeAttributesQuery(r)),t);const e=s.items,i=new Set;return await this._reschedule((()=>{for(const t of e)i.add(s.featureAdapter.getObjectId(t))}),t),i}catch(e){if(e===q)return new Set;throw e}}async executeQueryForSnapping(e,t){const{point:s,distance:i,types:a}=e;if(a===F.NONE)return{candidates:[]};const n=await this._reschedule((()=>this._checkQuerySupport(e.query)),t),u=!S(s.spatialReference,this.spatialReference);u&&await A(s.spatialReference,this.spatialReference);const o="number"==typeof i?i:i.x,c="number"==typeof i?i:i.y,h={xmin:s.x-o,xmax:s.x+o,ymin:s.y-c,ymax:s.y+c,spatialReference:s.spatialReference},l=u?k(h,this.spatialReference):h;if(!l)return{candidates:[]};const d=(await w(x(s),null,{signal:t}))[0],p=(await w(x(l),null,{signal:t}))[0];if(r(d)||r(p))return{candidates:[]};let y=new R(this._searchFeatures(this._getQueryBBoxes(p.toJSON())),null,this);y=await this._reschedule((()=>y.executeObjectIdsQuery(n)),t),y=await this._reschedule((()=>y.executeTimeQuery(n)),t),y=await this._reschedule((()=>y.executeAttributesQuery(n)),t);const f=d.toJSON(),m=u?k(f,this.spatialReference):f,_=u?Math.max(l.xmax-l.xmin,l.ymax-l.ymin)/2:i;return y.createSnappingResponse({...e,point:m,distance:_},s.spatialReference)}async executeQueryForLatestObservations(t={},s){if(!this.timeInfo||!this.timeInfo.trackIdField)throw new e(U,"Missing timeInfo or timeInfo.trackIdField",{query:t,timeInfo:this.timeInfo});let r,a=i(t);try{a=await this._schedule((()=>G(a,this.definitionExpression,this.spatialReference)),s),a=await this._reschedule((()=>this._checkQuerySupport(a)),s),r=await this._reschedule((()=>this._executeGeometryQuery(a,s)),s),r=await this._reschedule((()=>r.executeAggregateIdsQuery(a)),s),r=await this._reschedule((()=>r.executeObjectIdsQuery(a)),s),r=await this._reschedule((()=>r.executeTimeQuery(a)),s),r=await this._reschedule((()=>r.executeAttributesQuery(a)),s),r=await this._reschedule((()=>r.filterLatest()),s)}catch(e){if(e!==q)throw e;r=new R([],null,this)}return r.createQueryResponse(a)}async executeQueryForSummaryStatistics(e={},t,s){const{field:i,normalizationField:r,valueExpression:a}=t;return(await this._getQueryEngineResultForStats(e,{field:i,normalizationField:r,valueExpression:a},s)).createSummaryStatisticsResponse(e,t)}async executeQueryForUniqueValues(e={},t,s){const{field:i,valueExpression:r}=t;return(await this._getQueryEngineResultForStats(e,{field:i,valueExpression:r},s)).createUniqueValuesResponse(e,t)}async executeQueryForClassBreaks(e={},t,s){const{field:i,normalizationField:r,valueExpression:a}=t;return(await this._getQueryEngineResultForStats(e,{field:i,normalizationField:r,valueExpression:a},s)).createClassBreaksResponse(e,t)}async executeQueryForHistogram(e={},t,s){const{field:i,normalizationField:r,valueExpression:a}=t;return(await this._getQueryEngineResultForStats(e,{field:i,normalizationField:r,valueExpression:a},s)).createHistogramResponse(e,t)}async _schedule(e,t){return a(this._frameTask)?this._frameTask.schedule(e,t):e(N)}async _reschedule(e,t){return a(this._frameTask)?this._frameTask.reschedule(e,t):e(N)}_getAll(){if(!this._allItems){const e=[];this.featureStore.forEach((t=>e.push(t))),this._allItems=new R(e,null,this)}return this._allItems}async _executeGeometryQuery(e,t){const{geometry:s,outSR:i,spatialRel:r,returnGeometry:a,returnCentroid:u}=e,o=this.featureStore.featureSpatialReference,c=s&&o&&o!==s.spatialReference?k(s,o):s,h=a||u,l=Q(i)&&!S(this.spatialReference,i),d=this._geometryQueryCache?l&&h?JSON.stringify({originalFilterGeometry:s,spatialRelationship:r,outSpatialReference:i}):JSON.stringify({originalFilterGeometry:s,spatialRelationship:r}):null;if(d){const e=this._geometryQueryCache.get(d);if(!n(e))return e}const p=async e=>{if(l&&h){const t=await e.project(i);return d&&this._geometryQueryCache.put(d,t,t.size||1),t}return d&&this._geometryQueryCache.put(d,e,e.size||1),e};if(!c)return p(this._getAll());const y=this.featureAdapter;if("esriSpatialRelDisjoint"===r){const e=this._searchFeatures(this._getQueryBBoxes(s));if(!e.length)return p(this._getAll());let i,a;const n=new Set;for(const t of e)n.add(y.getObjectId(t));await this._reschedule((()=>{let e=0;i=new Array(n.size),this.featureStore.forEach((t=>i[e++]=t)),a=n}),t);return p(await this._reschedule((async()=>{const e=await B(r,c,this.geometryType,this.hasZ,this.hasM);return new R(await this._runSpatialFilter(i,(t=>!a.has(y.getObjectId(t))||e(y.getGeometry(t))),t),s,this)}),t))}const f=this._searchFeatures(this._getQueryBBoxes(s));if(!f.length){const e=new R([],s,this);return d&&this._geometryQueryCache.put(d,e,e.size||1),e}if(this._canExecuteSoloPass(c,e))return p(new R(f,s,this));const m=await B(r,c,this.geometryType,this.hasZ,this.hasM),x=await this._runSpatialFilter(f,(e=>m(y.getGeometry(e))),t);return p(new R(x,s,this))}async _runSpatialFilter(e,t,s){if(!t)return e;if(r(this._frameTask))return e.filter((e=>t(e)));let i=0;const a=new Array,n=async r=>{for(;i<e.length;){const u=e[i++];t(u)&&(a.push(u),r.madeProgress()),r.done&&await this._reschedule((e=>n(e)),s)}};return this._reschedule((e=>n(e)),s).then((()=>a))}_canExecuteSoloPass(e,t){const{geometryType:s}=this,{spatialRel:i}=t;return C(e)&&("esriSpatialRelEnvelopeIntersects"===i||"esriGeometryPoint"===s&&("esriSpatialRelIntersects"===i||"esriSpatialRelContains"===i||"esriSpatialRelWithin"===i))}_getQueryBBoxes(e){if(C(e)){if(_(e))return[y(e.xmin,e.ymin,e.xmax,e.ymax)];if(g(e))return e.rings.map((e=>y(Math.min(e[0][0],e[2][0]),Math.min(e[0][1],e[2][1]),Math.max(e[0][0],e[2][0]),Math.max(e[0][1],e[2][1]))))}return[m(f(),e)]}_searchFeatures(e){for(const t of e)this.featureStore.forEachInBounds(t,(e=>{Z.add(e)}));const t=new Array(Z.size);let s=0;return Z.forEach((e=>t[s++]=e)),Z.clear(),t}async _checkStatisticsSupport(t,s){if(t.distance<0||null!=t.geometryPrecision||t.multipatchOption||t.pixelSize||t.relationParam||t.text||t.outStatistics||t.groupByFieldsForStatistics||t.having||t.orderByFields)throw new e(U,"Unsupported query options",{query:t});return Promise.all([this._checkAttributesQuerySupport(t),this._checkStatisticsParamsSupport(s),T(t,this.geometryType,this.spatialReference),A(this.spatialReference,t.outSR)]).then((()=>t))}async _checkStatisticsParamsSupport(t){let s=[];if(t.valueExpression){const{arcadeUtils:e}=await M();s=e.extractFieldNames(t.valueExpression)}if(t.field&&s.push(t.field),t.normalizationField&&s.push(t.normalizationField),!s.length)throw new e(U,"params should have at least a field or valueExpression",{params:t});I(this.fieldsIndex,s,"params contains missing fields")}async _checkQuerySupport(t){if(t.distance<0||null!=t.geometryPrecision||t.multipatchOption||t.pixelSize||t.relationParam||t.text)throw new e(U,"Unsupported query options",{query:t});return Promise.all([this._checkAttributesQuerySupport(t),this._checkStatisticsQuerySupport(t),T(t,this.geometryType,this.spatialReference),A(this.spatialReference,t.outSR)]).then((()=>t))}_checkAttributesQuerySupport(t){const{outFields:s,orderByFields:i,returnDistinctValues:r,outStatistics:a}=t,n=a?a.map((e=>e.outStatisticFieldName&&e.outStatisticFieldName.toLowerCase())).filter(Boolean):[];if(i&&i.length>0){const e=" asc",t=" desc",s=i.map((s=>{const i=s.toLowerCase();return i.indexOf(e)>-1?i.split(e)[0]:i.indexOf(t)>-1?i.split(t)[0]:s})).filter((e=>-1===n.indexOf(e)));I(this.fieldsIndex,s,"orderByFields contains missing fields")}if(s&&s.length>0)I(this.fieldsIndex,s,"outFields contains missing fields");else if(r)throw new e(U,"outFields should be specified for returnDistinctValues",{query:t});E(this.fieldsIndex,t.where)}async _checkStatisticsQuerySupport(t){const{outStatistics:s,groupByFieldsForStatistics:i,having:r}=t,a=i&&i.length,n=s&&s.length;if(r){if(!a||!n)throw new e(U,"outStatistics and groupByFieldsForStatistics should be specified with having",{query:t});j(this.fieldsIndex,r,s)}if(n){if(!function(e){return e.every((e=>"exceedslimit"!==e.statisticType))}(s))return;const r=s.map((e=>e.onStatisticField)).filter(Boolean);I(this.fieldsIndex,r,"onStatisticFields contains missing fields"),a&&I(this.fieldsIndex,i,"groupByFieldsForStatistics contains missing fields");for(const i of s){const{onStatisticField:s,statisticType:r}=i;if(("percentile_disc"===r||"percentile_cont"===r)&&"statisticParameters"in i){const{statisticParameters:s}=i;if(!s)throw new e(U,"statisticParamters should be set for percentile type",{definition:i,query:t})}else if("count"!==r&&s&&b(s,this.fieldsIndex))throw new e(U,"outStatistics contains non-numeric fields",{definition:i,query:t})}}}async _getQueryEngineResultForStats(e={},t,s){let r;e=i(e);try{e=await this._schedule((()=>G(e,this.definitionExpression,this.spatialReference)),s),e=await this._reschedule((()=>this._checkStatisticsSupport(e,t)),s),r=await this._reschedule((()=>this._executeGeometryQuery(e,s)),s),r=await this._reschedule((()=>r.executeAggregateIdsQuery(e)),s),r=await this._reschedule((()=>r.executeObjectIdsQuery(e)),s),r=await this._reschedule((()=>r.executeTimeQuery(e)),s),r=await this._reschedule((()=>r.executeAttributesQuery(e)),s)}catch(e){if(e!==q)throw e;r=new R([],null,this)}return r}}const L=h(),V=h();export{J as Q};
