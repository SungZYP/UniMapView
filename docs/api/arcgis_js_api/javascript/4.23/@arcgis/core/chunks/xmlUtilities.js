/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import"../geometry.js";import{rasterRendererTypes as t}from"../rasterRenderers.js";import r from"../request.js";import{L as i}from"./Logger.js";import{b as n,i as s,u as o}from"../core/lang.js";import{aliasOf as a}from"../core/accessorSupport/decorators/aliasOf.js";import"./ensureType.js";import{property as l}from"../core/accessorSupport/decorators/property.js";import{subclass as c}from"../core/accessorSupport/decorators/subclass.js";import u,{g as f}from"../geometry/SpatialReference.js";import{s as h}from"./arcgisLayerUrl.js";import{u as m}from"./commonProperties.js";import d from"../layers/support/DimensionalDefinition.js";import{R as p}from"./RasterJobHandler.js";import x from"../layers/support/TileInfo.js";import{c as g,u as y,d as I}from"./vectorFieldUtils.js";import{n as b,b as v,a as R,c as w}from"./rasterRendererHelper.js";import{R as S,d as T}from"./RasterSymbolizer.js";import{c as k}from"./dataUtils.js";import _ from"../geometry/Extent.js";import H from"../core/Error.js";import{a as C}from"./JSONSupport.js";import{a as P}from"./Promise.js";import{onAbort as M}from"../core/promiseUtils.js";import{R as D}from"../layers/support/RasterInfo.js";import{g as J,a as B,p as O,d as z,b as E}from"./RawBlockCache.js";import{m as j,k as F,n as W}from"./pixelUtils.js";import{l as N,g as L,p as A,s as U,a as q,b as G,c as $,d as V,e as Y,f as X}from"./rasterProjectionHelper.js";import K from"../geometry/Point.js";const Q=i.getLogger("esri.layers.mixins.ImageryTileMixin"),Z=i=>{let o=class extends i{constructor(){super(...arguments),this._rasterJobHandler={instance:null,refCount:0,connectionPromise:null},this.bandIds=null,this.copyright=null,this.fullExtent=null,this.interpolation="nearest",this.multidimensionalDefinition=null,this.raster=null,this.rasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.tileInfo=null,this.symbolizer=null}set url(e){this._set("url",h(e,Q))}set renderer(e){this._set("renderer",e),this.updateRenderer()}async convertVectorFieldData(e,t){if(n(e))return null;const r=this._rasterJobHandler.instance,i=this.rasterInfo.dataType;return r?r.convertVectorFieldData({pixelBlock:e,dataType:i},t):g(e,i)}async createStreamlinesMesh(e,t){const r=this._rasterJobHandler.instance;return r?r.createStreamlinesMesh(e,t):k(e.rendererSettings,e.flowData,s(t.signal)?t.signal:(new AbortController).signal)}normalizeRasterFetchOptions(e){const{multidimensionalInfo:t}=this.rasterInfo;if(n(t))return e;let r=e.multidimensionalDefinition||this.multidimensionalDefinition;!n(r)&&r.length||(r=this._getDefaultSlice());const i=e.timeExtent||this.timeExtent;if(s(r)&&s(i)&&(s(i.start)||s(i.end))){var o,a;r=r.map((e=>e.clone()));const l=null==(o=t.variables.find((({name:e})=>e===r[0].variableName)))||null==(a=o.dimensions)?void 0:a.find((({name:e})=>"StdTime"===e)),c=r.find((({dimensionName:e})=>"StdTime"===e));if(!l||!c)return{...e,multidimensionalDefinition:null};const{start:u,end:f}=i,h=n(u)?null:u.getTime(),m=n(f)?null:f.getTime(),d=null!=h?h:m,p=null!=m?m:h;if(s(l.values)){const e=l.values.filter((e=>{if(Array.isArray(e)){if(d===p)return e[0]<=d&&e[1]>=d;const t=e[0]<=d&&e[1]>d||e[0]<p&&e[1]>=p,r=e[0]>=d&&e[1]<=p||e[0]<d&&e[1]>p;return t||r}return d===p?e===d:e>=d&&e<=p}));if(e.length){const t=e.sort(((e,t)=>{var r,i,n,s;if(d===p)return(null!=(n=e[0])?n:e)-(null!=(s=t[0])?s:t);return Math.abs((null!=(r=e[1])?r:e)-p)-Math.abs((null!=(i=t[1])?i:t)-p)}))[0];c.values=[t]}else r=null}else if(l.hasRegularIntervals&&l.extent){const[e,t]=l.extent;d>t||p<e?r=null:c.values=d===p?[d]:[Math.max(e,d),Math.min(t,p)]}}return{...e,multidimensionalDefinition:r}}async updateRenderer(){if(!this.loaded)return;if(JSON.stringify(this._cachedRendererJson)===JSON.stringify(this.renderer))return;const e=this._rasterJobHandler.instance;e&&(this.symbolizer.rendererJSON=b(this.renderer.toJSON()),this.symbolizer.bind(),await e.updateSymbolizer(this.symbolizer),this._cachedRendererJson=this.renderer.toJSON())}async applyRenderer(e,t){const r=e&&e.pixelBlock;if(!(s(r)&&r.pixels&&r.pixels.length>0))return null;let i;await this.updateRenderer();const n=this._rasterJobHandler.instance,{bandIds:o}=this;return i=n?await n.symbolize({...e,simpleStretchParams:t,bandIds:o}):this.symbolizer.symbolize({...e,simpleStretchParams:t,bandIds:o}),i}getTileUrl(e,t,r){return"RasterTileServer"===this.raster.datasetFormat?`${this.url}/tile/${e}/${t}/${r}`:""}getCompatibleTileInfo(e,t,r=!1){if(!this.loaded||n(t))return null;if(r&&e.equals(this.spatialReference))return this.tileInfo;const i=f(e);return x.create({size:256,spatialReference:e,origin:i?{x:i.origin[0],y:i.origin[1]}:{x:t.xmin,y:t.ymax}})}getCompatibleFullExtent(e){return this.loaded?(this._compatibleFullExtent&&this._compatibleFullExtent.spatialReference.equals(e)||(this._compatibleFullExtent=this.raster.computeExtent(e)),this._compatibleFullExtent):null}async fetchTile(e,t,i,o={}){if(o.requestAsImageElement){const n=this.getTileUrl(e,t,i);return r(n,{responseType:"image",query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:o.signal}).then((e=>e.data))}if(s(this.rasterInfo.multidimensionalInfo)&&(o=this.normalizeRasterFetchOptions(o),n(o.multidimensionalDefinition))){const r=o.tileInfo||this.rasterInfo.storageInfo.tileInfo;return{extent:this.raster.getTileExtentFromTileInfo(e,t,i,r),pixelBlock:null}}return await this._initJobHandler(),"raster-shaded-relief"===this.renderer.type&&(o={...o,buffer:{cols:1,rows:1}}),this.raster.fetchTile(e,t,i,o)}async fetchPixels(e,t,r,i={}){return s(this.rasterInfo.multidimensionalInfo)&&(i=this.normalizeRasterFetchOptions(i),n(i.multidimensionalDefinition))?{extent:e,pixelBlock:null}:(await this._initJobHandler(),this.raster.fetchPixels(e,t,r,i))}async identify(e,t={}){return s(this.rasterInfo.multidimensionalInfo)&&(t=this.normalizeRasterFetchOptions(t),n(t.multidimensionalDefinition))?{location:e,value:null}:this.raster.identify(e,t)}increaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount++}decreaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount--,this._rasterJobHandler.refCount<=0&&this._shutdownJobHandler()}hasStandardTime(){var e;const t=this.rasterInfo.multidimensionalInfo;if(!s(t)||"standard-time"!==this.rasterInfo.dataType)return!1;const r=null==(e=this.multidimensionalDefinition[0])?void 0:e.variableName;return t.variables.some((e=>e.name===r&&e.dimensions.some((e=>"StdTime"===e.name))))}getStandardTimeValue(e){return new Date(24*(e-25569)*3600*1e3).toString()}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=this._getDefaultSlice()),this._configDefaultRenderer()}_initJobHandler(){if(null!=this._rasterJobHandler.connectionPromise)return this._rasterJobHandler.connectionPromise;const e=new p;return this._rasterJobHandler.connectionPromise=e.initialize().then((()=>{this._rasterJobHandler.instance=e,this.raster.rasterJobHandler=e,this.renderer&&this.updateRenderer()})).catch((()=>null)),this._rasterJobHandler.connectionPromise}_shutdownJobHandler(){this._rasterJobHandler.instance&&this._rasterJobHandler.instance.destroy(),this._rasterJobHandler.instance=null,this._rasterJobHandler.connectionPromise=null,this._rasterJobHandler.refCount=0,this.raster.rasterJobHandler=null}_configDefaultInterpolation(){if(null==this.interpolation){var e;const t=v(this.rasterInfo,this.raster.tileType,null==(e=this.sourceJSON)?void 0:e.defaultResamplingMethod);this._set("interpolation",t)}}_getDefaultSlice(){const{multidimensionalInfo:e}=this.raster.rasterInfo;if(!s(e))return null;const t=e.variables[0];return t.dimensions.map((e=>{var r,i;return new d({variableName:t.name,dimensionName:e.name,values:[null!=(r=null==(i=e.values)?void 0:i[0])?r:e.extent[0]],isSlice:!0})}))}_configDefaultRenderer(){const e=this.raster.rasterInfo;var t;(this.bandIds||(this.bandIds=R(e)),this.renderer)||(this.renderer=w(e,{bandIds:this.bandIds,variableName:s(this.multidimensionalDefinition)?null==(t=this.multidimensionalDefinition[0])?void 0:t.variableName:null}));this.symbolizer?(this.symbolizer.rendererJSON=b(this.renderer.toJSON()),this.symbolizer.rasterInfo=e):this.symbolizer=new S({rendererJSON:this.renderer.toJSON(),rasterInfo:e});const r=this.symbolizer.bind();r.success||Q.warn("imagery-tile-mixin",r.error||"The given renderer is not supported by the layer.")}};return e([l()],o.prototype,"_cachedRendererJson",void 0),e([l()],o.prototype,"_compatibleFullExtent",void 0),e([l()],o.prototype,"_rasterJobHandler",void 0),e([l()],o.prototype,"bandIds",void 0),e([l({json:{origins:{service:{read:{source:"copyrightText"}}}}})],o.prototype,"copyright",void 0),e([l({type:_,json:{read:!1}}),a("rasterInfo.extent")],o.prototype,"fullExtent",void 0),e([l()],o.prototype,"interpolation",void 0),e([l()],o.prototype,"ioConfig",void 0),e([l({type:[d]})],o.prototype,"multidimensionalDefinition",void 0),e([l()],o.prototype,"raster",void 0),e([l({readOnly:!0}),a("raster.rasterInfo")],o.prototype,"rasterInfo",void 0),e([l()],o.prototype,"sourceJSON",void 0),e([l({type:u,json:{read:!1}}),a("rasterInfo.spatialReference")],o.prototype,"spatialReference",void 0),e([l({type:x,json:{read:!1}}),a("rasterInfo.storageInfo.tileInfo")],o.prototype,"tileInfo",void 0),e([l(m)],o.prototype,"url",null),e([l({types:t})],o.prototype,"renderer",null),e([l()],o.prototype,"symbolizer",void 0),o=e([c("esri.layers.ImageryTileMixin")],o),o};let ee=class extends(P(C)){constructor(){super(...arguments),this.rasterJobHandler=null,this.datasetName=null,this.datasetFormat=null,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}async init(){const e=N();this.addResolvingPromise(e),await this.when()}normalizeCtorArgs(e){return e&&e.ioConfig&&(e={...e,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:x.create(),...e.ioConfig}}),e}get _isGlobalWrappableSource(){const{rasterInfo:e}=this,t=L(e.spatialReference);return s(t)&&e.extent.width>=t/2}set url(e){this._set("url",h(e,i.getLogger(this.declaredClass)))}async open(e){throw new H("BaseRaster:open-not-implemented","open() is not implemented")}async fetchTile(e,t,r,i={}){const n=i.tileInfo||this.rasterInfo.storageInfo.tileInfo,s=this.getTileExtentFromTileInfo(e,t,r,n);return this.fetchPixels(s,n.size[0],n.size[1],i)}async identify(e,t={}){t=this._getRequestOptionsWithSliceId(t);const{spatialReference:r,extent:i}=this.rasterInfo,{datumTransformation:o}=t;let a=A(e,r,o);if(!i.intersects(a))return{location:a,value:null};if(s(this.rasterInfo.transform)){const e=this.rasterInfo.transform.inverseTransform(a);if(!this.rasterInfo.nativeExtent.intersects(e))return{location:e,value:null};a=e}let l=0;if(t.srcResolution){l=U(t.srcResolution,this.rasterInfo,this.ioConfig.sampling).pyramidLevel}else if(l=await this.computeBestPyramidLevelForLocation(e,t),null==l)return{location:a,value:null};const c=this.identifyPixelLocation(a,l,null);if(null===c)return{location:a,value:null};const{row:u,col:f,rowOffset:h,colOffset:m}=c,d=J(this.url,t.sliceId),p=`${l}/${u}/${f}`;let x=B(d,null,p);n(x)&&(x=this.fetchRawTile(l,u,f,t),O(d,null,p,x));const g=await x;if(n(g)||!g.pixels||0===g.pixels.length)return{location:a,value:null};const I=h*this.rasterInfo.storageInfo.blockHeight+m,b=!g.mask||g.mask[I]?g.pixels.map((e=>e[I])):null,v=this.rasterInfo.dataType;if(("vector-magdir"===v||"vector-uv"===v)&&(null==b?void 0:b.length)>1){return{location:a,value:b,magdirValue:"vector-magdir"===v?[b[0],b[1]]:y([b[0],b[1]]),pyramidLevel:l}}return{location:a,value:b,pyramidLevel:l}}async fetchPixels(e,t,r,i={}){if(e=q(e),(i=this._getRequestOptionsWithSliceId(i)).requestRawData)return this._fetchPixels(e,t,r,i);const s=L(e.spatialReference),o=G(e);if(n(s)||0===o||1===o&&this._isGlobalWrappableSource)return this._fetchPixels(e,t,r,i);if(o>=3)return{extent:e,pixelBlock:null};const a=[],{xmin:l,xmax:c}=e,u=Math.round(s/(c-l)*t),f=u-Math.round((s/2-l)/(c-l)*t);let h=0;const m=[];for(let n=0;n<=o;n++){const d=new _({xmin:0===n?l:-s/2,xmax:n===o?c-s*n:s/2,ymin:e.ymin,ymax:e.ymax,spatialReference:e.spatialReference}),p=0===n?u-f:n===o?t-h:u;h+=p,m.push(p);const x=i.disableWrapAround&&n>0?null:this._fetchPixels(d,p,r,i);a.push(x)}const d=(await Promise.all(a)).map((e=>null==e?void 0:e.pixelBlock));let p=null;const x={width:t,height:r};if(this.rasterJobHandler){p=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:d,srcMosaicSize:x,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:m},i)).pixelBlock}else p=j(d,x,{blockWidths:m});return{extent:e,srcExtent:$(e,this.rasterInfo.spatialReference,i.datumTransformation),pixelBlock:p}}async fetchRawPixels(e,t,r,i={}){t={x:Math.floor(t.x),y:Math.floor(t.y)};const n=await this._fetchRawTiles(e,t,r,i),{nativeExtent:o,nativePixelSize:a,storageInfo:l}=this.rasterInfo,c=2**e,u=a.x*c,f=a.y*c,h=new _({xmin:o.xmin+u*t.x,xmax:o.xmin+u*(t.x+r.width-1),ymin:o.ymax-f*(t.y+r.height-1),ymax:o.ymax-f*t.y,spatialReference:o.spatialReference});if(!n)return{extent:h,srcExtent:h,pixelBlock:null};const{pixelBlocks:m,mosaicSize:d}=n;if(1===m.length&&s(m[0])&&m[0].width===r.width&&m[0].height===r.height)return{extent:h,srcExtent:h,pixelBlock:n.pixelBlocks[0]};const p=e>0?l.pyramidBlockWidth:l.blockWidth,x=e>0?l.pyramidBlockHeight:l.blockHeight,g={x:t.x%p,y:t.y%x};let y;if(this.rasterJobHandler){y=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:m,srcMosaicSize:d,destDimension:r,clipOffset:g,clipSize:r,coefs:null,sampleSpacing:null,interpolation:i.interpolation,alignmentInfo:null,blockWidths:null},i)).pixelBlock}else y=j(m,d,{clipOffset:g,clipSize:r});return{extent:h,srcExtent:h,pixelBlock:y}}fetchRawTile(e,t,r,i){throw new H("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(e){return $(this.rasterInfo.extent,e)}decodePixelBlock(e,t){return!this.rasterJobHandler||t.useCanvas?T(e,t):this.rasterJobHandler.decode({data:e,options:t})}async request(e,t,i){var n,s;const{customFetchParameters:o}=this.ioConfig,{range:a,query:l,headers:c}=t;i=null!=(n=null!=(s=i)?s:t.retryCount)?n:this.ioConfig.retryCount;const u=a?{Range:`bytes=${a.from}-${a.to}`}:null;try{return await r(e,{...t,query:{...l,...o},headers:{...c,...u}})}catch(r){if(i>0)return i--,this.request(e,t,i);throw r}}getSliceIndex(e){const{multidimensionalInfo:t}=this.rasterInfo;if(!s(t))return null;if(!s(e)||0===e.length)return null;let r=0;const i=e[0].variableName;for(let n=0;n<t.variables.length;n++){const s=t.variables[n],o=s.dimensions;if(s.name!==i){r+=o.map((e=>this._getDimensionValuesCount(e))).reduce(((e,t)=>e+t));break}const a=o.map((e=>this._getDimensionValuesCount(e))),l=o.length;for(let t=0;t<l;t++){const i=e.find((e=>e.dimensionName===o[t].name));if(null==i)return null;const n=Array.isArray(i.values[0])?i.values[0][0]:i.values[0],s=this._getIndexFromDimensions(n,o[t]);if(-1===s)return null;a.shift(),r+=t===l-1?s:s*a.reduce(((e,t)=>e+t))}}return r}getTileExtentFromTileInfo(e,t,r,i){const n=i.lodAt(e);return this.getTileExtent({x:n.resolution,y:n.resolution},t,r,i.origin,i.spatialReference,i.size)}updateTileInfo(){const{storageInfo:e,spatialReference:t,extent:r,pixelSize:i}=this.rasterInfo;if(!e.tileInfo){const n=[],s=e.maximumPyramidLevel||0;let o=Math.max(i.x,i.y),a=1/.0254*96*o;for(let e=0;e<=s;e++)n.push({level:s-e,resolution:o,scale:a}),o*=2,a*=2;const l=new K({x:r.xmin,y:r.ymax,spatialReference:t});e.tileInfo=new x({origin:l,size:[e.blockWidth,e.blockHeight],spatialReference:t,lods:n}),e.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(e,t=512,r=512,i){const{width:n,height:s,nativeExtent:o,pixelSize:a,spatialReference:l}=e,c=new K({x:o.xmin,y:o.ymax,spatialReference:l});null==i&&(i=Math.max(0,Math.round(Math.log(Math.max(n,s))/Math.LN2-8)));const u=this.computeBlockBoundary(o,512,512,{x:o.xmin,y:o.ymax},[a],i);e.storageInfo=new D({blockWidth:t,blockHeight:r,pyramidBlockWidth:t,pyramidBlockHeight:r,origin:c,firstPyramidLevel:1,maximumPyramidLevel:i,blockBoundary:u})}async computeBestPyramidLevelForLocation(e,t={}){return 0}computeBlockBoundary(e,t,r,i,n,s=0,o=2){if(1===n.length&&s>0){n=[...n];let{x:e,y:t}=n[0];for(let r=0;r<s;r++)e*=o,t*=o,n.push({x:e,y:t})}const a=[],{x:l,y:c}=i;for(let i=0;i<n.length;i++){const{x:s,y:o}=n[i];a.push({minCol:Math.floor((e.xmin-l+.1*s)/t/s),maxCol:Math.floor((e.xmax-l-.1*s)/t/s),minRow:Math.floor((c-e.ymax+.1*o)/r/o),maxRow:Math.floor((c-e.ymin-.1*o)/r/o)})}return a}getPyramidPixelSize(e){const{nativePixelSize:t}=this.rasterInfo,{pyramidResolutions:r,pyramidScalingFactor:i}=this.rasterInfo.storageInfo;if(0===e)return t;if(s(r)&&r.length)return r[e-1];const n=i**e;return{x:t.x*n,y:t.y*n}}identifyPixelLocation(e,t,r){const{spatialReference:i,nativeExtent:n}=this.rasterInfo,{blockWidth:s,blockHeight:o,maximumPyramidLevel:a,origin:l}=this.rasterInfo.storageInfo,c=A(e,i,r);if(!n.intersects(c))return null;if(t<0||t>a)return null;const u=this.getPyramidPixelSize(t),{x:f,y:h}=u,m=(l.y-c.y)/h/o,d=(c.x-l.x)/f/s,p=Math.min(o-1,Math.floor((m-Math.floor(m))*o)),x=Math.min(s-1,Math.floor((d-Math.floor(d))*s));return{pyramidLevel:t,row:Math.floor(m),col:Math.floor(d),rowOffset:p,colOffset:x,srcLocation:c}}getTileExtent(e,t,r,i,n,s){const[o,a]=s,l=i.x+r*o*e.x,c=l+o*e.x,u=i.y-t*a*e.y,f=u-a*e.y;return new _({xmin:l,xmax:c,ymin:f,ymax:u,spatialReference:n})}getBlockWidthHeight(e){return{blockWidth:e>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:e>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(e,t,r){const i=this.rasterInfo.storageInfo.blockBoundary[e];return!i||i.maxRow<t||i.maxCol<r||i.minRow>t||i.minCol>r}async _fetchPixels(e,t,r,i={}){let n=G(e);if(n>=2)return{extent:e,pixelBlock:null};const a=this._getSourceDataInfo(e,t,r,i),{pyramidLevel:l,pyramidResolution:c,srcResolution:u,srcExtent:f,srcWidth:h,srcHeight:m}=a;if(0===h||0===m)return{extent:e,srcExtent:f,pixelBlock:null};const d=o(this.rasterInfo.transform),p="gcs-shift"===(null==d?void 0:d.type),x=s(L(e.spatialReference));!p&&x||(n=G(a.srcExtent,p));const g=this.rasterInfo.storageInfo,y={x:Math.floor((f.xmin-g.origin.x)/c.x+.1),y:Math.floor((g.origin.y-f.ymax)/c.y+.1)},b=await this._fetchRawTiles(l,y,{width:h,height:m,wrapCount:n},i);if(!b)return{extent:e,srcExtent:f,pixelBlock:null};const v=l>0?g.pyramidBlockWidth:g.blockWidth,R=l>0?g.pyramidBlockHeight:g.blockHeight,w=v===h&&R===m&&y.x%v==0&&y.y%R==0,S=new K({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/r,spatialReference:e.spatialReference}),T=!e.spatialReference.equals(this.rasterInfo.spatialReference),{datumTransformation:k}=i;if(!T&&w&&1===b.pixelBlocks.length&&v===t&&R===r&&u.x===S.x&&u.y===S.y)return{extent:e,srcExtent:f,pixelBlock:b.pixelBlocks[0]};const _=x&&s(L(f.spatialReference)),H=i.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");H&&!this.rasterJobHandler&&await N();const C=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:e,srcBufferExtent:b.extent,pixelSize:S.toJSON(),datumTransformation:k,rasterTransform:d,hasWrapAround:n>0||_,isAdaptive:!1!==this.ioConfig.optimizeProjectionAccuracy,includeGCSGrid:H},i):V({projectedExtent:e,srcBufferExtent:b.extent,pixelSize:S,datumTransformation:k,rasterTransform:d,hasWrapAround:n>0||_,isAdaptive:!1,includeGCSGrid:H});let P;const M=!i.requestRawData,D={rows:C.spacing[0],cols:C.spacing[1]},J=o(this._getRasterTileAlignmentInfo(l,b.extent.xmin)),{pixelBlocks:B,mosaicSize:O,isPartiallyFilled:z}=b;let E=null;if(this.rasterJobHandler){const e=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:B,srcMosaicSize:O,destDimension:M?{width:t,height:r}:null,coefs:M?C.coefficients:null,sampleSpacing:M?D:null,projectDirections:H,gcsGrid:H?C.gcsGrid:null,isUV:"vector-uv"===this.rasterInfo.dataType,interpolation:i.interpolation,alignmentInfo:J,blockWidths:null},i);({pixelBlock:P,localNorthDirections:E}=e)}else{const e=j(B,O,{alignmentInfo:J});P=M?F(e,{width:t,height:r},C.coefficients,D,i.interpolation):e,H&&C.gcsGrid&&(E=W({width:t,height:r},C.gcsGrid),P=I(P,this.rasterInfo.dataType,E))}return i.requestRawData||H?{srcExtent:f,pixelBlock:P,transformGrid:C,localNorthDirections:E,extent:e,isPartiallyFilled:z}:{srcExtent:f,extent:e,pixelBlock:P}}async _fetchRawTiles(e,t,r,i){const{origin:n,blockBoundary:o}=this.rasterInfo.storageInfo,{blockWidth:a,blockHeight:l}=this.getBlockWidthHeight(e);let{x:c,y:u}=t,{width:f,height:h,wrapCount:m}=r;const d=this._getRasterTileAlignmentInfo(e,0);i.buffer&&(c-=i.buffer.cols,u-=i.buffer.rows,f+=2*i.buffer.cols,h+=2*i.buffer.rows);let p=0,x=0,g=0;if(m&&s(d)){({worldColumnCountFromOrigin:x,originColumnOffset:g,rightPadding:p}=d);x*d.blockWidth-p>=c+f&&(p=0)}const y=Math.floor(c/a),I=Math.floor(u/l),b=Math.floor((c+f+p-1)/a),v=Math.floor((u+h+p-1)/l),R=o[e];if(!R)return null;const{minRow:w,minCol:S,maxCol:T,maxRow:k}=R;if(0===m&&(v<w||b<S||I>k||y>T))return null;const H=new Array;let C=!1;const P=null==this.ioConfig.allowPartialFill?i.allowPartialFill:this.ioConfig.allowPartialFill;for(let t=I;t<=v;t++)for(let r=y;r<=b;r++){let n=r;if(!i.disableWrapAround&&m&&s(d)&&x<=r&&(n=r-x-g),t>=w&&n>=S&&k>=t&&T>=n){const r=this._fetchRawTile(e,t,n,i);P?H.push(new Promise((e=>{r.then((t=>e(t))).catch((()=>{C=!0,e(null)}))}))):H.push(r)}else H.push(null)}if(0===H.length)return null;const M=await Promise.all(H),D={height:(v-I+1)*l,width:(b-y+1)*a},{spatialReference:J}=this.rasterInfo,B=this.getPyramidPixelSize(e),{x:O,y:z}=B;return{extent:new _({xmin:n.x+y*a*O,xmax:n.x+(b+1)*a*O,ymin:n.y-(v+1)*l*z,ymax:n.y-I*l*z,spatialReference:J}),pixelBlocks:M,mosaicSize:D,isPartiallyFilled:C}}_fetchRawTile(e,t,r,i){const s=this.rasterInfo.storageInfo.blockBoundary[e];if(!s)return Promise.resolve(null);const{minRow:o,minCol:a,maxCol:l,maxRow:c}=s;if(t<o||r<a||t>c||r>l)return Promise.resolve(null);const u=J(this.url,i.sliceId),f=`${e}/${t}/${r}`;let h=B(u,i.registryId,f);if(n(h)){const n=new AbortController;h=this.fetchRawTile(e,t,r,{...i,signal:n.signal}),O(u,i.registryId,f,h,n),h.catch((()=>z(u,i.registryId,f)))}return i.signal&&M(i,(()=>{E(u,i.registryId,f)})),h}_getIndexFromDimensions(e,t){const{extent:r,interval:i,unit:n,values:s}=t;if(null!=s&&s.length)return Array.isArray(s[0])?s.findIndex((t=>t[0]<=e&&t[1]>=e)):s.indexOf(e);if(e>r[1])return-1;const o=r[0];let a=-1;if("ISO8601"===n){var l;switch((null==(l=t.intervalUnit)?void 0:l.toLowerCase())||"seconds"){case"seconds":a=Math.round((e-o)/1e3/i);break;case"minutes":a=Math.round((e-o)/6e4/i);break;case"hours":a=Math.round((e-o)/36e5/i);break;case"days":a=Math.round((e-o)/864e5/i);break;case"years":a=Math.round((new Date(e).getUTCFullYear()-new Date(o).getUTCFullYear())/i);break;case"decades":a=Math.round((new Date(e).getUTCFullYear()-new Date(o).getUTCFullYear())/10/i)}return a}return Math.round((e-o)/i)}_getDimensionValuesCount(e){const{extent:t,interval:r,unit:i,values:n}=e;let s=(null==n?void 0:n.length)||0;if(s)return s;const o=t[0];if(0===s&&"ISO8601"===i){var a;switch((null==(a=e.intervalUnit)?void 0:a.toLowerCase())||"seconds"){case"seconds":s=Math.round((t[1]-t[0])/1e3/r);break;case"minutes":s=Math.round((t[1]-t[0])/6e4/r);break;case"hours":s=Math.round((t[1]-t[0])/36e5/r);break;case"days":s=Math.round((t[1]-t[0])/864e5/r);break;case"years":s=Math.round((new Date(t[1]).getUTCFullYear()-new Date(o).getUTCFullYear())/r);break;case"decades":s=Math.round((new Date(t[1]).getUTCFullYear()-new Date(o).getUTCFullYear())/10/r)}return s}return Math.round((t[1]-t[0])/r)}_getRasterTileAlignmentInfo(e,t){return null==this._rasterTileAlighmentInfo&&(this._rasterTileAlighmentInfo=Y(this.rasterInfo)),s(this._rasterTileAlighmentInfo.pyramidsInfo)?{startX:t,halfWorldWidth:this._rasterTileAlighmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlighmentInfo.hasGCSSShiftTransform,...this._rasterTileAlighmentInfo.pyramidsInfo[e]}:null}_getSourceDataInfo(e,t,r,i={}){const n={datumTransformation:i.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0};i.srcResolution&&(n.srcResolution=i.srcResolution,this._updateSourceDataInfo(e,n));const s=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:o,srcHeight:a,pyramidLevel:l}=n,c=o/t,u=a/r,f=l<s&&c*u>=16;if(f||l===s&&(c>8||u>8)||(0===o||0===a)){const o=new K({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/r,spatialReference:e.spatialReference});let a=X(o,this.rasterInfo.spatialReference,e,n.datumTransformation);const h=!a||i.srcResolution&&a.x+a.y<i.srcResolution.x+i.srcResolution.y;if(f&&i.srcResolution&&h){const e=Math.round(Math.log(Math.max(c,u))/Math.LN2)-1;if(s-l+3>=e){const t=2**e;a={x:i.srcResolution.x*t,y:i.srcResolution.y*t}}}a&&(n.srcResolution=a,this._updateSourceDataInfo(e,n))}return(n.srcWidth/t>8||n.srcHeight/r>8)&&(n.srcWidth=0,n.srcHeight=0),n}_updateSourceDataInfo(e,t){t.srcWidth=0,t.srcHeight=0;const r=this.rasterInfo.spatialReference,{srcResolution:i,datumTransformation:n}=t,{pyramidLevel:s,pyramidResolution:a,excessiveReading:l}=U(i,this.rasterInfo,this.ioConfig.sampling);if(l)return;let c=t.srcExtent||$(e,r,n);if(null==c)return;const u=o(this.rasterInfo.transform);u&&(c=u.inverseTransform(c)),t.srcExtent=c;const f=Math.ceil((c.xmax-c.xmin)/a.x-.1),h=Math.ceil((c.ymax-c.ymin)/a.y-.1);t.pyramidLevel=s,t.pyramidResolution=a,t.srcWidth=f,t.srcHeight=h}_getRequestOptionsWithSliceId(e){return s(this.rasterInfo.multidimensionalInfo)&&null==e.sliceId&&(e={...e,sliceId:this.getSliceIndex(e.multidimensionalDefinition)}),e}};e([l()],ee.prototype,"_rasterTileAlighmentInfo",void 0),e([l({readOnly:!0})],ee.prototype,"_isGlobalWrappableSource",null),e([l(m)],ee.prototype,"url",null),e([l({type:String,json:{write:!0}})],ee.prototype,"datasetName",void 0),e([l({type:String,json:{write:!0}})],ee.prototype,"datasetFormat",void 0),e([l()],ee.prototype,"rasterInfo",void 0),e([l()],ee.prototype,"ioConfig",void 0),e([l()],ee.prototype,"sourceJSON",void 0),ee=e([c("esri.layers.support.rasterDatasets.BaseRaster")],ee);const te=ee;function re(e,t){if(!e||!t)return[];let r=t;t.indexOf("/")>-1?(r=t.slice(0,t.indexOf("/")),t=t.slice(t.indexOf("/")+1)):t="";const i=[];if(t){const n=re(e,r);for(let e=0;e<n.length;e++){re(n[e],t).forEach((e=>i.push(e)))}return i}const n=e.getElementsByTagNameNS("*",r);if(!n||0===n.length)return[];for(let e=0;e<n.length;e++)i.push(n[e]||n.item[e]);return i}function ie(e,t){if(!e||!t)return null;let r=t;t.indexOf("/")>-1?(r=t.slice(0,t.indexOf("/")),t=t.slice(t.indexOf("/")+1)):t="";const i=re(e,r);return i.length>0?t?ie(i[0],t):i[0]:null}function ne(e,t=null){const r=t?ie(e,t):e;let i;return r?(i=r.textContent||r.nodeValue,i?i.trim():null):null}function se(e,t){const r=re(e,t),i=[];let n;for(let e=0;e<r.length;e++)n=r[e].textContent||r[e].nodeValue,n&&(n=n.trim(),""!==n&&i.push(n));return i}function oe(e,t=null){const r=ne(e,t);return null==r?void 0:r.split(" ").map((e=>Number(e)))}function ae(e,t){return se(e,t).map((e=>Number(e)))}function le(e,t){const r=ne(e,t);return Number(r)}function ce(e,t){var r;const i=null==e||null==(r=e.nodeName)?void 0:r.toLowerCase(),n=t.toLowerCase();return i.slice(i.lastIndexOf(":")+1)===n}function ue(e){return e.nodeName.slice(e.nodeName.lastIndexOf(":")+1)}export{te as B,Z as I,re as a,ie as b,le as c,ae as d,oe as e,se as f,ne as g,ue as h,ce as i};
