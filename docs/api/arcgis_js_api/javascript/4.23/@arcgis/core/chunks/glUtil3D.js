/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{b as e,i as t,p as i}from"../core/lang.js";import{P as s,R as r,S as n,A as a}from"./basicInterfaces.js";import{P as o}from"../core/scheduling.js";import{b as l,q as c,p as f,g as h,F as d,j as u,h as m,f as g,v as p,Z as _}from"./mathUtils.js";import{a as v}from"./Util.js";import{C as b,b as x,D as P}from"./Material.js";import{g as T,c as y,a as E}from"./geometryDataUtils.js";import{V as A}from"./VertexAttribute.js";import{k as I,t as O}from"./mat4.js";import{a as w,b as S,c as U,B as M}from"./BufferView.js";import{c as B}from"./mat4f64.js";import{g as D,a as F}from"./ShaderBuilder.js";import{f as L}from"./vec4f64.js";import{c as N}from"./mat4f32.js";import{P as C,C as z,S as H,D as k,U as j,T as V,a as R,b as G,c as q}from"./enums.js";import{w as K,T as W}from"./Texture.js";import{V as Y}from"./VertexElementDescriptor.js";import{V as Q,B as X}from"./VertexArrayObject.js";class ${constructor(e,t,i,s){this.primitiveIndices=e,this._numIndexPerPrimitive=t,this.indices=i,this.position=s,this.center=l(),v(e.length>=1),v(i.length%this._numIndexPerPrimitive==0),v(i.length>=e.length*this._numIndexPerPrimitive),v(3===s.size||4===s.size);const{data:r,size:n}=s,a=e.length;let o=n*i[this._numIndexPerPrimitive*e[0]];Z.clear(),Z.push(o),this.bbMin=c(r[o],r[o+1],r[o+2]),this.bbMax=f(this.bbMin);for(let t=0;t<a;++t){const s=this._numIndexPerPrimitive*e[t];for(let e=0;e<this._numIndexPerPrimitive;++e){o=n*i[s+e],Z.push(o);let t=r[o];this.bbMin[0]=Math.min(t,this.bbMin[0]),this.bbMax[0]=Math.max(t,this.bbMax[0]),t=r[o+1],this.bbMin[1]=Math.min(t,this.bbMin[1]),this.bbMax[1]=Math.max(t,this.bbMax[1]),t=r[o+2],this.bbMin[2]=Math.min(t,this.bbMin[2]),this.bbMax[2]=Math.max(t,this.bbMax[2])}}h(this.center,this.bbMin,this.bbMax,.5),this.radius=.5*Math.max(Math.max(this.bbMax[0]-this.bbMin[0],this.bbMax[1]-this.bbMin[1]),this.bbMax[2]-this.bbMin[2]);let d=this.radius*this.radius;for(let e=0;e<Z.length;++e){o=Z.getItemAt(e);const t=r[o]-this.center[0],i=r[o+1]-this.center[1],s=r[o+2]-this.center[2],n=t*t+i*i+s*s;if(n<=d)continue;const a=Math.sqrt(n),l=.5*(a-this.radius);this.radius=this.radius+l,d=this.radius*this.radius;const c=l/a;this.center[0]+=t*c,this.center[1]+=i*c,this.center[2]+=s*c}Z.clear()}getCenter(){return this.center}getBSRadius(){return this.radius}getBBMin(){return this.bbMin}getBBMax(){return this.bbMax}getChildren(){if(this._children)return this._children;if(d(this.bbMin,this.bbMax)>1){const e=h(l(),this.bbMin,this.bbMax,.5),t=this.primitiveIndices.length,i=new Uint8Array(t),s=new Array(8);for(let e=0;e<8;++e)s[e]=0;const{data:r,size:n}=this.position;for(let a=0;a<t;++a){let t=0;const o=this._numIndexPerPrimitive*this.primitiveIndices[a];let l=n*this.indices[o],c=r[l],f=r[l+1],h=r[l+2];for(let e=1;e<this._numIndexPerPrimitive;++e){l=n*this.indices[o+e];const t=r[l],i=r[l+1],s=r[l+2];t<c&&(c=t),i<f&&(f=i),s<h&&(h=s)}c<e[0]&&(t|=1),f<e[1]&&(t|=2),h<e[2]&&(t|=4),i[a]=t,++s[t]}let a=0;for(let e=0;e<8;++e)s[e]>0&&++a;if(a<2)return;const o=new Array(8);for(let e=0;e<8;++e)o[e]=s[e]>0?new Uint32Array(s[e]):void 0;for(let e=0;e<8;++e)s[e]=0;for(let e=0;e<t;++e){const t=i[e];o[t][s[t]++]=this.primitiveIndices[e]}this._children=new Array(8);for(let e=0;e<8;++e)void 0!==o[e]&&(this._children[e]=new $(o[e],this._numIndexPerPrimitive,this.indices,this.position))}return this._children}static prune(){Z.prune()}}const Z=new o({deallocator:null});class J extends b{constructor(e,t=[],i=s.Triangle,r=-1){super(),this._primitiveType=i,this.edgeIndicesLength=r,this.type=x.Geometry,this._vertexAttributes=new Map,this._indices=new Map,this._boundingInfo=null;for(const[t,i]of e)i&&this._vertexAttributes.set(t,{...i});if(null==t||0===t.length){const e=function(e){const t=e.values().next().value;if(null==t)return 0;return t.data.length/t.size}(this._vertexAttributes),t=T(e);this.edgeIndicesLength=this.edgeIndicesLength<0?e:this.edgeIndicesLength;for(const e of this._vertexAttributes.keys())this._indices.set(e,t)}else for(const[e,i]of t)i&&(this._indices.set(e,ee(i)),e===A.POSITION&&(this.edgeIndicesLength=this.edgeIndicesLength<0?this._indices.get(e).length:this.edgeIndicesLength))}cloneShallow(){const e=new J([],void 0,this._primitiveType,void 0),{_vertexAttributes:t,_indices:i}=e;return this._vertexAttributes.forEach(((e,i)=>{t.set(i,e)})),this._indices.forEach(((e,t)=>{i.set(t,e)})),e.screenToWorldRatio=this.screenToWorldRatio,e._boundingInfo=this._boundingInfo,e}get vertexAttributes(){return this._vertexAttributes}getMutableAttribute(e){const t=this._vertexAttributes.get(e);return t&&!t.exclusive&&(t.data=Array.from(t.data),t.exclusive=!0),t}get indices(){return this._indices}get indexCount(){const e=this._indices.values().next().value;return e?e.length:0}get primitiveType(){return this._primitiveType}get faceCount(){return this.indexCount/3}get boundingInfo(){return e(this._boundingInfo)&&(this._boundingInfo=this._calculateBoundingInfo()),this._boundingInfo}computeAttachmentOrigin(e){return this.primitiveType===s.Triangle?this._computeAttachmentOriginTriangles(e):this._computeAttachmentOriginPoints(e)}_computeAttachmentOriginTriangles(e){const t=this.indices.get(A.POSITION),i=this.vertexAttributes.get(A.POSITION);return y(i,t,e)}_computeAttachmentOriginPoints(e){const t=this.indices.get(A.POSITION),i=this.vertexAttributes.get(A.POSITION);return E(i,t,e)}invalidateBoundingInfo(){this._boundingInfo=null}_calculateBoundingInfo(){const e=this.indices.get(A.POSITION);if(0===e.length)return null;const t=this.primitiveType===s.Triangle?3:1;v(e.length%t==0,"Indexing error: "+e.length+" not divisible by "+t);const i=T(e.length/t),r=this.vertexAttributes.get(A.POSITION);return new $(i,t,e,r)}}function ee(e){if(e.BYTES_PER_ELEMENT===Uint16Array.BYTES_PER_ELEMENT)return e;for(const t of e)if(t>=65536)return e;return new Uint16Array(e)}var te;!function(e){e[e.Color=0]="Color",e[e.Depth=1]="Depth",e[e.Normal=2]="Normal",e[e.Shadow=3]="Shadow",e[e.Highlight=4]="Highlight",e[e.Draped=5]="Draped",e[e.Occlusion=6]="Occlusion",e[e.Alpha=7]="Alpha",e[e.COUNT=8]="COUNT"}(te||(te={}));class ie{constructor(e){this._material=e.material,this._techniqueRep=e.techniqueRep,this._output=e.output}dispose(){this._techniqueRep.release(this._technique)}get technique(){return this._technique}ensureTechnique(e,t,i=this._output){return this._technique=this._techniqueRep.releaseAndAcquire(e,this._material.getTechniqueConfig(i,t),this._technique),this._technique}ensureResources(e){return r.LOADED}}function se(e,t,i,s,r=1){const n=i.typedBuffer,a=i.typedBufferStride,o=e.length;if(s*=a,1===r)for(let i=0;i<o;++i)n[s]=t[e[i]],s+=a;else for(let i=0;i<o;++i){const o=t[e[i]];for(let e=0;e<r;e++)n[s]=o,s+=a}}function re(e,t,i,s){const r=i.typedBuffer,n=i.typedBufferStride,a=e.length;s*=n;for(let i=0;i<a;++i){const a=2*e[i];r[s]=t[a],r[s+1]=t[a+1],s+=n}}function ne(e,t,i,s,r){const n=i.typedBuffer,a=i.typedBufferStride,o=e.length;if(s*=a,null==r||1===r)for(let i=0;i<o;++i){const r=3*e[i];n[s]=t[r],n[s+1]=t[r+1],n[s+2]=t[r+2],s+=a}else for(let i=0;i<o;++i){const o=3*e[i];for(let e=0;e<r;++e)n[s]=t[o],n[s+1]=t[o+1],n[s+2]=t[o+2],s+=a}}function ae(e,t,i,s,r=1){const n=i.typedBuffer,a=i.typedBufferStride,o=e.length;if(s*=a,1===r)for(let i=0;i<o;++i){const r=4*e[i];n[s]=t[r],n[s+1]=t[r+1],n[s+2]=t[r+2],n[s+3]=t[r+3],s+=a}else for(let i=0;i<o;++i){const o=4*e[i];for(let e=0;e<r;++e)n[s]=t[o],n[s+1]=t[o+1],n[s+2]=t[o+2],n[s+3]=t[o+3],s+=a}}function oe(e,t,i,s,r,n=1){if(!i)return void ne(e,t,s,r,n);const a=s.typedBuffer,o=s.typedBufferStride,l=e.length,c=i[0],f=i[1],h=i[2],d=i[4],u=i[5],m=i[6],g=i[8],p=i[9],_=i[10],v=i[12],b=i[13],x=i[14];if(r*=o,1===n)for(let i=0;i<l;++i){const s=3*e[i],n=t[s],l=t[s+1],P=t[s+2];a[r]=c*n+d*l+g*P+v,a[r+1]=f*n+u*l+p*P+b,a[r+2]=h*n+m*l+_*P+x,r+=o}else for(let i=0;i<l;++i){const s=3*e[i],l=t[s],P=t[s+1],T=t[s+2],y=c*l+d*P+g*T+v,E=f*l+u*P+p*T+b,A=h*l+m*P+_*T+x;for(let e=0;e<n;++e)a[r]=y,a[r+1]=E,a[r+2]=A,r+=o}}function le(e,t,i,s,r,n=1){if(!i)return void ne(e,t,s,r,n);const a=i,o=s.typedBuffer,l=s.typedBufferStride,c=e.length,f=a[0],h=a[1],d=a[2],u=a[4],m=a[5],g=a[6],p=a[8],_=a[9],v=a[10],b=!I(a),x=1e-6,P=.999999;if(r*=l,1===n)for(let i=0;i<c;++i){const s=3*e[i],n=t[s],a=t[s+1],c=t[s+2];let T=f*n+u*a+p*c,y=h*n+m*a+_*c,E=d*n+g*a+v*c;if(b){const e=T*T+y*y+E*E;if(e<P&&e>x){const t=1/Math.sqrt(e);T*=t,y*=t,E*=t}}o[r+0]=T,o[r+1]=y,o[r+2]=E,r+=l}else for(let i=0;i<c;++i){const s=3*e[i],a=t[s],c=t[s+1],T=t[s+2];let y=f*a+u*c+p*T,E=h*a+m*c+_*T,A=d*a+g*c+v*T;if(b){const e=y*y+E*E+A*A;if(e<P&&e>x){const t=1/Math.sqrt(e);y*=t,E*=t,A*=t}}for(let e=0;e<n;++e)o[r+0]=y,o[r+1]=E,o[r+2]=A,r+=l}}function ce(e,t,i,s,r,n=1){if(!i)return void ae(e,t,s,r,n);const a=i,o=s.typedBuffer,l=s.typedBufferStride,c=e.length,f=a[0],h=a[1],d=a[2],u=a[4],m=a[5],g=a[6],p=a[8],_=a[9],v=a[10],b=!I(a),x=1e-6,P=.999999;if(r*=l,1===n)for(let i=0;i<c;++i){const s=4*e[i],n=t[s],a=t[s+1],c=t[s+2],T=t[s+3];let y=f*n+u*a+p*c,E=h*n+m*a+_*c,A=d*n+g*a+v*c;if(b){const e=y*y+E*E+A*A;if(e<P&&e>x){const t=1/Math.sqrt(e);y*=t,E*=t,A*=t}}o[r+0]=y,o[r+1]=E,o[r+2]=A,o[r+3]=T,r+=l}else for(let i=0;i<c;++i){const s=4*e[i],a=t[s],c=t[s+1],T=t[s+2],y=t[s+3];let E=f*a+u*c+p*T,A=h*a+m*c+_*T,I=d*a+g*c+v*T;if(b){const e=E*E+A*A+I*I;if(e<P&&e>x){const t=1/Math.sqrt(e);E*=t,A*=t,I*=t}}for(let e=0;e<n;++e)o[r+0]=E,o[r+1]=A,o[r+2]=I,o[r+3]=y,r+=l}}function fe(e,t,i,s,r,n=1){const a=s.typedBuffer,o=s.typedBufferStride,l=e.length;if(r*=o,1===n){if(4===i)for(let i=0;i<l;++i){const s=4*e[i];a[r]=t[s],a[r+1]=t[s+1],a[r+2]=t[s+2],a[r+3]=t[s+3],r+=o}else if(3===i)for(let i=0;i<l;++i){const s=3*e[i];a[r]=t[s],a[r+1]=t[s+1],a[r+2]=t[s+2],a[r+3]=255,r+=o}}else if(4===i)for(let i=0;i<l;++i){const s=4*e[i];for(let e=0;e<n;++e)a[r]=t[s],a[r+1]=t[s+1],a[r+2]=t[s+2],a[r+3]=t[s+3],r+=o}else if(3===i)for(let i=0;i<l;++i){const s=3*e[i];for(let e=0;e<n;++e)a[r]=t[s],a[r+1]=t[s+1],a[r+2]=t[s+2],a[r+3]=255,r+=o}}function he(e,t,i,s,r,n){for(const a of t.fieldNames){const t=e.vertexAttributes.get(a),o=e.indices.get(a);if(t&&o)switch(a){case A.POSITION:{v(3===t.size);const e=r.getField(a,M);e&&oe(o,t.data,i,e,n);break}case A.NORMAL:{v(3===t.size);const e=r.getField(a,M);e&&le(o,t.data,s,e,n);break}case A.UV0:{v(2===t.size);const e=r.getField(a,U);e&&re(o,t.data,e,n);break}case A.COLOR:{v(3===t.size||4===t.size);const e=r.getField(a,S);e&&fe(o,t.data,t.size,e,n);break}case A.SYMBOLCOLOR:{v(3===t.size||4===t.size);const e=r.getField(a,S);e&&fe(o,t.data,t.size,e,n);break}case A.TANGENT:{v(4===t.size);const e=r.getField(a,w);e&&ce(o,t.data,s,e,n);break}}}}function de(e,t){if(t.slicePlaneEnabled){e.extensions.add("GL_OES_standard_derivatives"),t.sliceEnabledForVertexPrograms&&(e.vertex.uniforms.add("slicePlaneOrigin","vec3"),e.vertex.uniforms.add("slicePlaneBasis1","vec3"),e.vertex.uniforms.add("slicePlaneBasis2","vec3")),e.fragment.uniforms.add("slicePlaneOrigin","vec3"),e.fragment.uniforms.add("slicePlaneBasis1","vec3"),e.fragment.uniforms.add("slicePlaneBasis2","vec3");const i=D`struct SliceFactors {
float front;
float side0;
float side1;
float side2;
float side3;
};
SliceFactors calculateSliceFactors(vec3 pos) {
vec3 rel = pos - slicePlaneOrigin;
vec3 slicePlaneNormal = -cross(slicePlaneBasis1, slicePlaneBasis2);
float slicePlaneW = -dot(slicePlaneNormal, slicePlaneOrigin);
float basis1Len2 = dot(slicePlaneBasis1, slicePlaneBasis1);
float basis2Len2 = dot(slicePlaneBasis2, slicePlaneBasis2);
float basis1Dot = dot(slicePlaneBasis1, rel);
float basis2Dot = dot(slicePlaneBasis2, rel);
return SliceFactors(
dot(slicePlaneNormal, pos) + slicePlaneW,
-basis1Dot - basis1Len2,
basis1Dot - basis1Len2,
-basis2Dot - basis2Len2,
basis2Dot - basis2Len2
);
}
bool sliceByFactors(SliceFactors factors) {
return factors.front < 0.0
&& factors.side0 < 0.0
&& factors.side1 < 0.0
&& factors.side2 < 0.0
&& factors.side3 < 0.0;
}
bool sliceEnabled() {
return dot(slicePlaneBasis1, slicePlaneBasis1) != 0.0;
}
bool sliceByPlane(vec3 pos) {
return sliceEnabled() && sliceByFactors(calculateSliceFactors(pos));
}
#define rejectBySlice(_pos_) sliceByPlane(_pos_)
#define discardBySlice(_pos_) { if (sliceByPlane(_pos_)) discard; }`,s=D`vec4 applySliceHighlight(vec4 color, vec3 pos) {
SliceFactors factors = calculateSliceFactors(pos);
const float HIGHLIGHT_WIDTH = 1.0;
const vec4 HIGHLIGHT_COLOR = vec4(0.0, 0.0, 0.0, 0.3);
factors.front /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.front);
factors.side0 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side0);
factors.side1 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side1);
factors.side2 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side2);
factors.side3 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side3);
if (sliceByFactors(factors)) {
return color;
}
float highlightFactor = (1.0 - step(0.5, factors.front))
* (1.0 - step(0.5, factors.side0))
* (1.0 - step(0.5, factors.side1))
* (1.0 - step(0.5, factors.side2))
* (1.0 - step(0.5, factors.side3));
return mix(color, vec4(HIGHLIGHT_COLOR.rgb, color.a), highlightFactor * HIGHLIGHT_COLOR.a);
}`,r=t.sliceHighlightDisabled?D`#define highlightSlice(_color_, _pos_) (_color_)`:D`
        ${s}
        #define highlightSlice(_color_, _pos_) (sliceEnabled() ? applySliceHighlight(_color_, _pos_) : (_color_))
      `;t.sliceEnabledForVertexPrograms&&e.vertex.code.add(i),e.fragment.code.add(i),e.fragment.code.add(r)}else{const i=D`#define rejectBySlice(_pos_) false
#define discardBySlice(_pos_) {}
#define highlightSlice(_color_, _pos_) (_color_)`;t.sliceEnabledForVertexPrograms&&e.vertex.code.add(i),e.fragment.code.add(i)}}function ue(e,t,i){me(e,t,i.slicePlane,{origin:i.origin})}function me(e,i,s,r){if(i.slicePlaneEnabled)if(t(s)){if(u(ge,s.origin),u(pe,s.basis1),u(_e,s.basis2),t(r)&&t(r.origin)&&m(ge,s.origin,r.origin),t(r)&&t(r.view)){const e=t(r.origin)?O(ve,r.view,r.origin):r.view;g(pe,pe,ge),g(_e,_e,ge),p(ge,ge,e),p(pe,pe,e),p(_e,_e,e),m(pe,pe,ge),m(_e,_e,ge)}e.setUniform3fv("slicePlaneOrigin",ge),e.setUniform3fv("slicePlaneBasis1",pe),e.setUniform3fv("slicePlaneBasis2",_e)}else e.setUniform3fv("slicePlaneBasis1",_),e.setUniform3fv("slicePlaneBasis2",_),e.setUniform3fv("slicePlaneOrigin",_)}const ge=l(),pe=l(),_e=l(),ve=B(),be=L(1,1,0,1),xe=L(1,0,1,1);function Pe(e){e.fragment.uniforms.add("depthTex","sampler2D"),e.fragment.uniforms.add("highlightViewportPixelSz","vec4"),e.fragment.constants.add("occludedHighlightFlag","vec4",be).add("unoccludedHighlightFlag","vec4",xe),e.fragment.code.add(D`void outputHighlight() {
vec4 fragCoord = gl_FragCoord;
float sceneDepth = texture2D(depthTex, (fragCoord.xy - highlightViewportPixelSz.xy) * highlightViewportPixelSz.zw).r;
if (fragCoord.z > sceneDepth + 5e-7) {
gl_FragColor = occludedHighlightFlag;
}
else {
gl_FragColor = unoccludedHighlightFlag;
}
}`)}function Te(e,t){e.bindTexture(t.highlightDepthTexture,"depthTex"),e.setUniform4f("highlightViewportPixelSz",0,0,t.inverseViewport[0],t.inverseViewport[1])}function ye(e,t){e.fragment.uniforms.add("terrainDepthTexture","sampler2D"),e.fragment.uniforms.add("nearFar","vec2"),e.fragment.uniforms.add("inverseViewport","vec2"),e.fragment.code.add(D`
    // Compare the linearized depths of fragment and terrain. Discard fragments on the wrong side of the terrain.
    void terrainDepthTest(vec4 fragCoord, float fragmentDepth){

      float terrainDepth = linearDepthFromTexture(terrainDepthTexture, fragCoord.xy * inverseViewport, nearFar);
      if(fragmentDepth ${t.cullAboveGround?">":"<="} terrainDepth){
        discard;
      }
    }
  `)}function Ee(e,t){t.multipassTerrainEnabled&&t.terrainLinearDepthTexture&&e.bindTexture(t.terrainLinearDepthTexture,"terrainDepthTexture")}function Ae(e,t,i){e.setUniform3f("cameraPosition",i[3]-t[0],i[7]-t[1],i[11]-t[2])}function Ie(e,t){e.setUniformMatrix4fv("proj",t)}function Oe(e,t,i){O(Ue,i,t),e.setUniform3fv("localOrigin",t),e.setUniformMatrix4fv("view",Ue)}function we(e,t){Oe(e,t.origin,t.camera.viewMatrix)}function Se(e,t){e.setUniform4fv("viewport",t.camera.fullViewport)}const Ue=N();class Me{constructor(e,t){this._module=e,this._loadModule=t}get(){return this._module}async reload(){return this._module=await this._loadModule(),this._module}}class Be{constructor(e,t,i){this.release=i,t&&(this._config=t.snapshot()),this._program=this.initializeProgram(e),this._pipeline=this.initializePipeline(e)}destroy(){this._program=i(this._program),this._pipeline=this._config=null}reload(e){i(this._program),this._program=this.initializeProgram(e),this._pipeline=this.initializePipeline(e)}get program(){return this._program}get key(){return this._config.key}get configuration(){return this._config}bindPass(e,t){}bindMaterial(e,t){}bindDraw(e){}bindPipelineState(e,t=null,i){e.setPipelineState(this.getPipelineState(t,i))}ensureAttributeLocations(e){this.program.assertCompatibleVertexAttributeLocations(e)}get primitiveType(){return C.TRIANGLES}getPipelineState(e,t){return this._pipeline}}class De{constructor(){this._key="",this._keyDirty=!1,this._parameterBits=this._parameterBits?this._parameterBits.map((()=>0)):[],this._parameterNames||(this._parameterNames=[])}get key(){return this._keyDirty&&(this._keyDirty=!1,this._key=String.fromCharCode.apply(String,this._parameterBits)),this._key}snapshot(){const e=this._parameterNames,t={key:this.key};for(const i of e)t[i]=this[i];return t}}function Fe(e={}){return(t,i)=>{var s,r;t._parameterNames=null!=(s=t._parameterNames)?s:[],t._parameterNames.push(i);const n=t._parameterNames.length-1,a=e.count||2,o=Math.ceil(Math.log2(a)),l=null!=(r=t._parameterBits)?r:[0];let c=0;for(;l[c]+o>16;)c++,c>=l.length&&l.push(0);t._parameterBits=l;const f=l[c],h=(1<<o)-1<<f;l[c]+=o,Object.defineProperty(t,i,{get(){return this[n]},set(e){if(this[n]!==e&&(this[n]=e,this._keyDirty=!0,this._parameterBits[c]=this._parameterBits[c]&~h|+e<<f&h,"number"!=typeof e&&"boolean"!=typeof e))throw"Configuration value for "+i+" must be boolean or number, got "+typeof e}})}}class Le{constructor(e,t,i){this._context=e,this._locations=i,this._textures=new Map,this._freeTextureUnits=new o({deallocator:null}),this._glProgram=e.programCache.acquire(t.generateSource("vertex"),t.generateSource("fragment"),i),this._glProgram.stop=()=>{throw new Error("Wrapped _glProgram used directly")},this._fragmentUniforms=K()?t.fragmentUniforms.entries:null}dispose(){this._glProgram.dispose()}get glName(){return this._glProgram.glName}get isCompiled(){return this._glProgram.isCompiled}setUniform1b(e,t){this._glProgram.setUniform1i(e,t?1:0)}setUniform1i(e,t){this._glProgram.setUniform1i(e,t)}setUniform1f(e,t){this._glProgram.setUniform1f(e,t)}setUniform1fv(e,t){this._glProgram.setUniform1fv(e,t)}setUniform1iv(e,t){this._glProgram.setUniform1iv(e,t)}setUniform2f(e,t,i){this._glProgram.setUniform2f(e,t,i)}setUniform2fv(e,t){this._glProgram.setUniform2fv(e,t)}setUniform2iv(e,t){this._glProgram.setUniform2iv(e,t)}setUniform3f(e,t,i,s){this._glProgram.setUniform3f(e,t,i,s)}setUniform3fv(e,t){this._glProgram.setUniform3fv(e,t)}setUniform3iv(e,t){this._glProgram.setUniform3iv(e,t)}setUniform4f(e,t,i,s,r){this._glProgram.setUniform4f(e,t,i,s,r)}setUniform4fv(e,t){this._glProgram.setUniform4fv(e,t)}setUniform4iv(e,t){this._glProgram.setUniform4iv(e,t)}setUniformMatrix3fv(e,t){this._glProgram.setUniformMatrix3fv(e,t)}setUniformMatrix4fv(e,t){this._glProgram.setUniformMatrix4fv(e,t)}assertCompatibleVertexAttributeLocations(e){e.locations!==this._locations&&console.error("VertexAttributeLocations are incompatible")}stop(){this._textures.clear(),this._freeTextureUnits.clear()}bindTexture(t,i){if(e(t)||null==t.glName){const e=this._textures.get(i);return e&&(this._context.bindTexture(null,e.unit),this._freeTextureUnit(e),this._textures.delete(i)),null}let s=this._textures.get(i);return null==s?(s=this._allocTextureUnit(t),this._textures.set(i,s)):s.texture=t,this._context.useProgram(this),this.setUniform1i(i,s.unit),this._context.bindTexture(t,s.unit),s.unit}rebindTextures(){this._context.useProgram(this),this._textures.forEach(((e,t)=>{this._context.bindTexture(e.texture,e.unit),this.setUniform1i(t,e.unit)})),t(this._fragmentUniforms)&&this._fragmentUniforms.forEach((e=>{if(("sampler2D"===e.type||"samplerCube"===e.type)&&!this._textures.has(e.name))throw new Error(`Texture sampler ${e.name} has no bound texture`)}))}_allocTextureUnit(e){return{texture:e,unit:0===this._freeTextureUnits.length?this._textures.size:this._freeTextureUnits.pop()}}_freeTextureUnit(e){this._freeTextureUnits.push(e.unit)}}const Ne={func:z.LESS},Ce={func:z.ALWAYS},ze={mask:255},He={mask:0},ke=e=>({function:{func:z.NOTEQUAL,ref:e,mask:e},operation:{fail:H.KEEP,zFail:H.KEEP,zPass:H.KEEP}}),je=e=>({function:{func:z.ALWAYS,ref:e,mask:e},operation:{fail:H.KEEP,zFail:H.KEEP,zPass:H.REPLACE}}),Ve={function:{func:z.ALWAYS,ref:n.OutlineVisualElementMask,mask:n.OutlineVisualElementMask},operation:{fail:H.KEEP,zFail:H.KEEP,zPass:H.ZERO}},Re={function:{func:z.ALWAYS,ref:n.OutlineVisualElementMask,mask:n.OutlineVisualElementMask},operation:{fail:H.KEEP,zFail:H.KEEP,zPass:H.REPLACE}},Ge={function:{func:z.EQUAL,ref:n.OutlineVisualElementMask,mask:n.OutlineVisualElementMask},operation:{fail:H.KEEP,zFail:H.KEEP,zPass:H.KEEP}},qe={function:{func:z.NOTEQUAL,ref:n.OutlineVisualElementMask,mask:n.OutlineVisualElementMask},operation:{fail:H.KEEP,zFail:H.KEEP,zPass:H.KEEP}};function Ke(e,t){const i={hasModelTransformation:!1,...t};if(i.hasModelTransformation)return i.linearDepth?void e.vertex.code.add(D`vec4 transformPositionWithDepth(mat4 proj, mat4 view, mat4 model, vec3 pos, vec2 nearFar, out float depth) {
vec4 eye = view * (model * vec4(pos, 1.0));
depth = (-eye.z - nearFar[0]) / (nearFar[1] - nearFar[0]) ;
return proj * eye;
}`):void e.vertex.code.add(D`vec4 transformPosition(mat4 proj, mat4 view, mat4 model, vec3 pos) {
return proj * (view * (model * vec4(pos, 1.0)));
}`);i.linearDepth?e.vertex.code.add(D`vec4 transformPositionWithDepth(mat4 proj, mat4 view, vec3 pos, vec2 nearFar, out float depth) {
vec4 eye = view * vec4(pos, 1.0);
depth = (-eye.z - nearFar[0]) / (nearFar[1] - nearFar[0]) ;
return proj * eye;
}`):e.vertex.code.add(D`vec4 transformPosition(mat4 proj, mat4 view, vec3 pos) {
return proj * (view * vec4(pos, 1.0));
}`)}function We(e,t){e.fragment.include(F),t.output===te.Shadow?(e.extensions.add("GL_OES_standard_derivatives"),e.fragment.code.add(D`float _calculateFragDepth(const in float depth) {
const float SLOPE_SCALE = 2.0;
const float BIAS = 2.0 * .000015259;
float m = max(abs(dFdx(depth)), abs(dFdy(depth)));
float result = depth + SLOPE_SCALE * m + BIAS;
return clamp(result, .0, .999999);
}
void outputDepth(float _linearDepth) {
gl_FragColor = float2rgba(_calculateFragDepth(_linearDepth));
}`)):t.output===te.Depth&&e.fragment.code.add(D`void outputDepth(float _linearDepth) {
gl_FragColor = float2rgba(_linearDepth);
}`)}const Ye=.1,Qe=.001;function Xe(e,t){const i=e.fragment;switch(t.alphaDiscardMode){case a.Blend:i.code.add(D`
        #define discardOrAdjustAlpha(color) { if (color.a < ${D.float(.001)}) { discard; } }
      `);break;case a.Opaque:i.code.add(D`void discardOrAdjustAlpha(inout vec4 color) {
color.a = 1.0;
}`);break;case a.Mask:i.uniforms.add("textureAlphaCutoff","float"),i.code.add(D`#define discardOrAdjustAlpha(color) { if (color.a < textureAlphaCutoff) { discard; } else { color.a = 1.0; } }`);break;case a.MaskBlend:e.fragment.uniforms.add("textureAlphaCutoff","float"),e.fragment.code.add(D`#define discardOrAdjustAlpha(color) { if (color.a < textureAlphaCutoff) { discard; } }`)}}function $e(e){e.code.add(D`vec4 premultiplyAlpha(vec4 v) {
return vec4(v.rgb * v.a, v.a);
}
vec3 rgb2hsv(vec3 c) {
vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);
vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);
float d = q.x - min(q.w, q.y);
float e = 1.0e-10;
return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), min(d / (q.x + e), 1.0), q.x);
}
vec3 hsv2rgb(vec3 c) {
vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}
float rgb2v(vec3 c) {
return max(c.x, max(c.y, c.z));
}`)}new Y(A.POSITION,3,k.FLOAT,0,12),new Y(A.POSITION,3,k.FLOAT,0,20),new Y(A.UV0,2,k.FLOAT,12,20),new Y(A.POSITION,3,k.FLOAT,0,32),new Y(A.NORMAL,3,k.FLOAT,12,32),new Y(A.UV0,2,k.FLOAT,24,32),new Y(A.POSITION,3,k.FLOAT,0,16),new Y(A.COLOR,4,k.UNSIGNED_BYTE,12,16);const Ze=[new Y(A.POSITION,2,k.FLOAT,0,8)],Je=[new Y(A.POSITION,2,k.FLOAT,0,16),new Y(A.UV0,2,k.FLOAT,8,16)];function et(e,t=Ze,i=P,s=-1,r=1){let n=null;if(t===Je)n=new Float32Array([s,s,0,0,r,s,1,0,s,r,0,1,r,r,1,1]);else n=new Float32Array([s,s,r,s,s,r,r,r]);return new Q(e,i,{geometry:t},{geometry:X.createVertex(e,j.STATIC_DRAW,n)})}function tt(e,t=Ze,i=P){const s=new Float32Array([-1,-1,3,-1,-1,3]);return new Q(e,i,{geometry:t},{geometry:X.createVertex(e,j.STATIC_DRAW,s)})}function it(e,t=4){return new W(e,{target:V.TEXTURE_2D,pixelFormat:R.RGBA,dataType:G.UNSIGNED_BYTE,samplingMode:q.NEAREST,width:t,height:t})}function st(e,t,i=4){const s=new Uint8Array(i*i*4);for(let e=0;e<s.length;e+=4)s[e+0]=255*t[0],s[e+1]=255*t[1],s[e+2]=255*t[2],s[e+3]=255*t[3];return new W(e,{target:V.TEXTURE_2D,pixelFormat:R.RGBA,dataType:G.UNSIGNED_BYTE,samplingMode:q.NEAREST,width:i,height:i},s)}function rt(e){return new W(e,{target:V.TEXTURE_2D,pixelFormat:R.RGBA,dataType:G.UNSIGNED_BYTE,samplingMode:q.NEAREST,width:1,height:1},new Uint8Array([255,255,255,255]))}export{He as A,Ge as B,$e as C,Xe as D,rt as E,Je as F,ie as G,st as H,it as I,ke as J,je as K,Ze as L,xe as M,tt as N,We as O,Le as P,$ as Q,Me as R,Be as S,Ke as T,Se as U,le as V,ae as W,fe as X,Oe as Y,we as a,Ie as b,De as c,te as d,J as e,de as f,Ee as g,Ae as h,ue as i,oe as j,Pe as k,Te as l,ye as m,ze as n,Re as o,Fe as p,Ve as q,Ye as r,Qe as s,Ne as t,et as u,se as v,he as w,me as x,Ce as y,qe as z};
