/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import e from"./Error.js";import{L as t}from"../chunks/Logger.js";import{i as r,b as n,a as o,r as i}from"./lang.js";import"../chunks/object.js";import"../config.js";import"../chunks/string.js";const s=(u=globalThis,{setTimeout:(e,t)=>{const r=u.setTimeout(e,t);return{remove:()=>u.clearTimeout(r)}}});var u;function c(e){return e&&("function"==typeof e.on||"function"==typeof e.addEventListener)}function l(e,t,r){if(!c(e))throw new TypeError("target is not a Evented or EventTarget object");if("on"in e)return e.on(t,r);if(Array.isArray(t)){const n=t.slice();for(const t of n)e.addEventListener(t,r);return{remove(){for(const t of n)e.removeEventListener(t,r)}}}return e.addEventListener(t,r),{remove(){e.removeEventListener(t,r)}}}function f(e,t,r){if(!c(e))throw new TypeError("target is not a Evented or EventTarget object");if("once"in e)return e.once(t,r);const n=l(e,t,(t=>{n.remove(),r.call(e,t)}));return{remove(){n.remove()}}}function a(e,t,r){let n=!1;const o=l(e,t,(t=>{n||r.call(e,t)}));return{resume(){n=!1},pause(){n=!0},remove(){o.remove()}}}const m={Win:"Meta",Scroll:"ScrollLock",Spacebar:" ",Down:"ArrowDown",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Del:"Delete",Apps:"ContextMenu",Esc:"Escape",Multiply:"*",Add:"+",Subtract:"-",Decimal:".",Divide:"/"};function h({key:e}){return m[e]||e}function p(e){return Promise.all(e)}function v(e,t){const r=e.slice();return Promise.all(e.map(((e,r)=>t(e,r)))).then((e=>r.filter(((t,r)=>e[r]))))}function w(e){return new Promise(((t,r)=>{try{e(t,r)}catch(e){Promise.resolve().then((()=>r(e)))}}))}function b(t="Aborted"){return new e("AbortError",t)}function d(e,t="Aborted"){if(E(e))throw b(t)}function g(e){return r(e)?"aborted"in e?e:e.signal:e}function E(e){const t=g(e);return r(t)&&t.aborted}function j(e){if(D(e))throw e}function A(e){if(!D(e))throw e}function T(e,t){const r=g(e);if(!n(r)){if(!r.aborted)return f(r,"abort",(()=>t()));t()}}function P(e,t){const r=g(e);if(!n(r))return d(r),f(r,"abort",(()=>t(b())))}function y(e,t){const r=g(t);return n(r)?e:new Promise(((r,n)=>{let o=T(t,(()=>n(b())));const s=()=>o=i(o);e.then(s,s),e.then(r,n)}))}function L(t,r,n){return Promise.race([t,$(r).then((()=>{throw new e("timeout",`Did not resolve within ${r} milliseconds (${null!=n?n:"timeout"})`)}))])}function D(e){return e&&"AbortError"===e.name}function k(e){return e.catch((e=>{if(!D(e))throw e}))}function C(e,r=t.getLogger("esri")){return e.catch((e=>{D(e)||r.error(e)}))}function S(){let e=null;const t=new Promise(((t,r)=>{e={promise:void 0,resolve:t,reject:r}}));return e.promise=t,e}function M(e){if(!e)return;if("function"!=typeof e.forEach){const t=Object.keys(e);return M(t.map((t=>e[t]))).then((e=>{const r={};return t.forEach(((t,n)=>r[t]=e[n])),r}))}const t=e;return w((e=>{const r=[];let n=t.length;0===n&&e(r),t.forEach((t=>{const o={promise:t||Promise.resolve(t)};r.push(o),o.promise.then((e=>{o.value=e})).catch((e=>{o.error=e})).then((()=>{--n,0===n&&e(r)}))}))}))}function U(e){return M(e).then((e=>e.filter((e=>!!e.value)).map((e=>e.value))))}function x(e){return Promise.reject(e)}function R(e){return Promise.resolve(e)}function $(e,t,r){const n=new AbortController;return T(r,(()=>n.abort())),new Promise(((r,o)=>{let i=setTimeout((()=>{i=0,r(t)}),e);T(n,(()=>{i&&(clearTimeout(i),o(b()))}))}))}function O(t,r,n,o){const i=n&&"abort"in n?n:null;null!=o||i||(o=n);let s=setTimeout((()=>{s=0,i&&i.abort()}),r);const u=()=>o||new e("promiseUtils:timeout","The wrapped promise did not resolve within "+r+" ms");return t.then((e=>{if(0===s)throw u();return clearTimeout(s),e}),(e=>{throw clearTimeout(s),0===s?u():e}))}function W(e){return e&&"function"==typeof e.then}function q(e){return W(e)?e:Promise.resolve(e)}function z(e,t=-1){let r,n,i,s,u=null;const c=(...l)=>{if(r){n=l,s&&s.reject(b()),s=S();const e=o(s.promise);if(u){const e=u;u=null,e.abort()}return e}if(i=s||S(),s=null,t>0){const n=new AbortController;r=q(e(...l,n.signal));const o=r;$(t).then((()=>{r===o&&(s?n.abort():u=n)}))}else r=1,r=q(e(...l));const f=()=>{const e=n;n=i=r=u=null,null!=e&&c(...e)},a=r,m=i;return a.then(f,f),a.then(m.resolve,m.reject),o(m.promise)};return c}function B(){let e,t;const r=new Promise(((r,n)=>{e=r,t=n})),n=t=>{e(t)};return n.resolve=t=>e(t),n.reject=e=>t(e),n.timeout=(e,t)=>s.setTimeout((()=>n.reject(t)),e),n.promise=r,n}function F(e,t){return e.then(t,t)}function G(e,t){let n,o=new AbortController;const i=e(o.signal);let s={promise:i,finished:!1,abort:()=>{o&&(o.abort(),o=null)}};const u=()=>{s&&(s.finished=!0,s=null),r(n)&&(n.remove(),n=null),o=null};return i.then(u,u),n=T(t,(()=>{r(s)&&s.abort()})),s}function H(e){return Promise.resolve().then((()=>{d(e)}))}export{$ as after,p as all,F as always,s as c,w as create,b as createAbortError,S as createDeferred,B as createResolver,G as createTask,z as debounce,h as e,M as eachAlways,U as eachAlwaysValues,v as filter,c as i,k as ignoreAbortErrors,D as isAbortError,E as isAborted,W as isPromiseLike,C as logOnError,l as o,T as onAbort,P as onAbortOrThrow,a as p,x as reject,R as resolve,j as throwIfAbortError,d as throwIfAborted,A as throwIfNotAbortError,O as timeout,H as waitTick,q as when,y as whenOrAbort,L as whenOrTimeout};
