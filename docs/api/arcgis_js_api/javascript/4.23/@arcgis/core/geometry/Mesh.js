/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{_ as t}from"../chunks/tslib.es6.js";import e from"../core/Error.js";import{HandleOwnerMixin as r}from"../core/HandleOwner.js";import{L as n}from"../chunks/Loadable.js";import{L as o}from"../chunks/Logger.js";import{i as s,b as i}from"../core/lang.js";import{a}from"../chunks/Promise.js";import{whenOrAbort as c,eachAlwaysValues as l,isAborted as p,throwIfAborted as u}from"../core/promiseUtils.js";import{watch as h}from"../core/reactiveUtils.js";import{property as f}from"../core/accessorSupport/decorators/property.js";import"../chunks/ensureType.js";import{subclass as m}from"../core/accessorSupport/decorators/subclass.js";import{b as g,f as d,E as x,n as v,s as y,h as w,Z as j,v as b,e as A,q as k}from"../chunks/mathUtils.js";import M from"./Extent.js";import R from"./Geometry.js";import F from"./Point.js";import P from"./Polygon.js";import{c as O,a as U,b as z,d as L,f as C}from"../chunks/axisAngleDegrees.js";import S,{M as $}from"./support/MeshComponent.js";import{i as T,u as I,g as B,a as E,M as G}from"../chunks/georeference.js";import{t as q}from"../chunks/triangulationUtils.js";import{projectPointToVector as Z,computeTranslationToOriginAndRotation as D}from"./projection.js";import{makeRelative as V,removeFile as H}from"../core/urlUtils.js";import{f as N}from"../chunks/mat3.js";import{b as W}from"../chunks/quatf64.js";import{c as _}from"../chunks/mat4f64.js";import{a as J}from"../chunks/projectionEllipsoid.js";import{p as K,a as Q,b as X,c as Y,d as tt,e as et}from"../chunks/projection.js";import{e as rt}from"../chunks/mat4.js";import"../chunks/object.js";import"../config.js";import"../chunks/string.js";import"../core/Accessor.js";import"../chunks/deprecate.js";import"../chunks/get.js";import"../chunks/utils.js";import"../chunks/handleUtils.js";import"../chunks/metadata.js";import"../chunks/ArrayPool.js";import"../chunks/tracking.js";import"../chunks/watch.js";import"../core/scheduling.js";import"../chunks/nextTick.js";import"../core/Handles.js";import"../core/Collection.js";import"../chunks/Evented.js";import"../chunks/shared.js";import"../chunks/common.js";import"./SpatialReference.js";import"../chunks/JSONSupport.js";import"../chunks/writer.js";import"./support/webMercatorUtils.js";import"../chunks/Ellipsoid.js";import"../chunks/reader.js";import"../core/accessorSupport/decorators/cast.js";import"../chunks/extentUtils.js";import"../chunks/zmUtils.js";import"../chunks/quat.js";import"./support/MeshMaterial.js";import"../Color.js";import"../chunks/colorUtils.js";import"./support/MeshTexture.js";import"../chunks/persistableUrlUtils.js";import"../chunks/screenshotUtils.js";import"./support/MeshMaterialMetallicRoughness.js";import"../chunks/unitUtils.js";import"../chunks/jsonMap.js";import"../chunks/BufferView.js";import"../chunks/vec2.js";import"../chunks/vec3.js";import"../chunks/earcut.js";import"../chunks/deduplicate.js";import"./Multipoint.js";import"../chunks/pe.js";import"../chunks/assets.js";import"../request.js";import"../kernel.js";import"./Polyline.js";import"../chunks/aaBoundingRect.js";import"../chunks/geodesicConstants.js";import"./support/GeographicTransformation.js";import"./support/GeographicTransformationStep.js";import"../chunks/zscale.js";const nt=o.getLogger("esri.geometry.support.meshUtils.centerAt");function ot(t,e,r){var n;if(!t.vertexAttributes||!t.vertexAttributes.position)return;const o=null!=(n=null==r?void 0:r.origin)?n:t.origin;if(s(t.transform))null!=(null==r?void 0:r.geographic)&&r.geographic!==t.transform.geographic&&nt.warn(`Specifying the 'geographic' parameter (${r.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`),function(t,e,r){const n=e.x-r.x,o=e.y-r.y,s=e.hasZ&&r.hasZ?e.z-r.z:0,i=t.origin;t.origin=[i[0]+n,i[1]+o,i[2]+s]}(t.transform,e,o);else{T(t.spatialReference,r)?function(t,e,r){const n=I(t.vertexAttributes,r,{geographic:!0}),{position:o,normal:s,tangent:i}=B(n,e,{geographic:!0});t.vertexAttributes.position=o,t.vertexAttributes.normal=s,t.vertexAttributes.tangent=i,t.vertexAttributesChanged()}(t,e,o):function(t,e,r){const n=it,o=st;if(!Z(e,o,t.spatialReference))return void nt.error(`Failed to project centerAt location (wkid:${e.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid})`);if(!Z(r,n,t.spatialReference)){const e=t.origin;n[0]=e.x,n[1]=e.y,n[2]=e.z,nt.error(`Failed to project specified origin (wkid:${r.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}).`)}(function(t,e,r){if(!t)return;for(let n=0;n<t.length;n+=3)for(let o=0;o<3;o++)t[n+o]+=e[o]-r[o]})(t.vertexAttributes.position,o,n),t.vertexAttributesChanged()}(t,e,o)}}const st=g(),it=g();function at(t){const e=H(t.url);return r=>{var n;const o=V(r,e,e),s=o?o.replace(/^ *\.\//,""):null;return null!=(n=t.files.get(s))?n:r}}async function ct(t,r){return t instanceof Blob?lt.fromBlob(t):"string"==typeof t?new lt(t):Array.isArray(t)?async function(t,r){const n=new Map;let o=null;const s=await l(t.map((async t=>({name:t.name,source:await ct(t instanceof Blob?t:t.source,r)})))),a=[];for(const t of s)t&&(p(r)?t.source.dispose():a.push(t));u(r);for(const{name:t,source:e}of a)(i(o)||/\.(gltf|glb)/i.test(t))&&(o=e.url),n.set(t,e.url),e.files&&e.files.forEach(((t,e)=>n.set(e,t)));if(i(o))throw new e("mesh-load-external:missing-files","Missing files to load external mesh source");return new lt(o,(()=>a.forEach((({source:t})=>t.dispose()))),n)}(t,r):async function(t,e){const{default:r}=await c(import("../request.js").then((t=>t.r)),e),n="string"==typeof t.multipart[0]?await Promise.all(t.multipart.map((async t=>(await r(t,{responseType:"array-buffer"})).data))):t.multipart;return lt.fromBlob(new Blob(n))}(t,r)}class lt{constructor(t,e=(()=>{}),r=new Map){this.url=t,this.dispose=e,this.files=r}static fromBlob(t){const e=URL.createObjectURL(t);return new lt(e,(()=>URL.revokeObjectURL(e)))}}const pt=o.getLogger("esri.geometry.support.meshUtils.offset");function ut(t,e,r){if(t.vertexAttributes&&t.vertexAttributes.position)if(s(t.transform))null!=(null==r?void 0:r.geographic)&&r.geographic!==t.transform.geographic&&pt.warn(`Specifying the 'geographic' parameter (${r.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`),function(t,e){const r=t.origin;t.origin=d(g(),r,e)}(t.transform,e);else{T(t.spatialReference,r)?function(t,e){const r=t.spatialReference,n=t.vertexAttributes.position,o=t.vertexAttributes.normal,i=t.vertexAttributes.tangent,a=new Float64Array(n.length),c=s(o)?new Float32Array(o.length):null,l=s(i)?new Float32Array(i.length):null,p=t.extent.center,u=ft;D(r,[p.x,p.y,p.z],mt,J(r)),N(gt,mt),x(u,e,gt),K(n,r,a),s(o)&&Q(o,n,a,r,c);s(i)&&X(i,n,a,r,l);ht(a,u),Y(a,n,r),s(o)&&tt(c,n,a,r,o);s(i)&&et(l,n,a,r,i);t.vertexAttributesChanged()}(t,e):function(t,e){ht(t.vertexAttributes.position,e),t.vertexAttributesChanged()}(t,e)}}function ht(t,e){if(t)for(let r=0;r<t.length;r+=3)for(let n=0;n<3;n++)t[r+n]+=e[n]}const ft=g(),mt=_(),gt=W();const dt={position:[-.5,-.5,0,.5,-.5,0,.5,.5,0,-.5,.5,0],normal:[0,0,1,0,0,1,0,0,1,0,0,1],uv:[0,1,1,1,1,0,0,0],faces:[0,1,2,0,2,3],facingAxisOrderSwap:{east:[3,1,2],west:[-3,-1,2],north:[-1,3,2],south:[1,-3,2],up:[1,2,3],down:[1,-2,-3]}};function xt(t,e,r){!function(t){for(let e=0;e<t.position.length;e+=3)t.position[e+2]+=.5}(t),function(t,e){if(null==e)return;const r="number"==typeof e?[e,e,e]:[null!=e.width?e.width:1,null!=e.depth?e.depth:1,null!=e.height?e.height:1];jt[0]=r[0],jt[4]=r[1],jt[8]=r[2];for(let e=0;e<t.position.length;e+=3){for(let r=0;r<3;r++)wt[r]=t.position[e+r];x(wt,wt,jt);for(let r=0;r<3;r++)t.position[e+r]=wt[r]}if(r[0]!==r[1]||r[1]!==r[2]){jt[0]=1/r[0],jt[4]=1/r[1],jt[8]=1/r[2];for(let e=0;e<t.normal.length;e+=3){for(let r=0;r<3;r++)wt[r]=t.normal[e+r];x(wt,wt,jt),v(wt,wt);for(let r=0;r<3;r++)t.normal[e+r]=wt[r]}}}(t,r&&r.size);const{vertexAttributes:n,transform:o}=E(t,e,r);return{vertexAttributes:new $({...n,uv:t.uv}),transform:o,components:[new S({faces:t.faces,material:r&&r.material||null})],spatialReference:e.spatialReference}}const vt={faceDescriptions:[{axis:[0,-1,0],uvOrigin:[0,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[1,0,0],uvOrigin:[.25,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,1,0],uvOrigin:[.5,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[-1,0,0],uvOrigin:[.75,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[0,0,1],uvOrigin:[0,.375],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,0,-1],uvOrigin:[0,.875],corners:[[-1,1],[1,1],[1,-1],[-1,-1]]}],uvScales:[[0,0],[1,0],[1,1],[0,1]],faceVertexOffsets:[0,1,2,0,2,3]},yt={south:0,east:1,north:2,west:3,up:4,down:5},wt=g(),jt=W(),bt=o.getLogger("esri.geometry.support.meshUtils.rotate");function At(t,e,r){if(!t.vertexAttributes||!t.vertexAttributes.position||0===e[3])return;const n=t.spatialReference;if(s(t.transform)){var o;null!=(null==r?void 0:r.geographic)&&r.geographic!==t.transform.geographic&&bt.warn(`Specifying the 'geographic' parameter (${r.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`);const s=null!=(o=null==r?void 0:r.origin)?o:t.transform.getOriginPoint(n);!function(t,e,r){const n=y(Mt,r.x,r.y,r.z),o=w(Mt,n,t.origin);t.applyLocalInverse(o,Rt),t.rotation=U(t.rotation,e,O()),t.applyLocalInverse(o,o),w(o,o,Rt),t.translation=d(g(),t.translation,o)}(t.transform,e,s)}else{var i;const n=null!=(i=null==r?void 0:r.origin)?i:t.origin;T(t.spatialReference,r)?function(t,e,r){const n=t.spatialReference,o=J(n),i=Ut;Z(r,i,o)||Z(t.origin,i,o);const a=t.vertexAttributes.position,c=t.vertexAttributes.normal,l=t.vertexAttributes.tangent,p=new Float64Array(a.length),u=s(c)?new Float32Array(c.length):null,h=s(l)?new Float32Array(l.length):null;D(o,i,Pt,o),N(Ot,Pt);const f=Ft;x(z(Ft),z(e),Ot),f[3]=e[3],K(a,n,p),s(c)&&Q(c,a,p,n,u);s(l)&&X(l,a,p,n,h);kt(p,f,3,i),Y(p,a,n),s(c)&&(kt(u,f,3),tt(u,a,p,n,c));s(l)&&(kt(h,f,4),et(h,a,p,n,l));t.vertexAttributesChanged()}(t,e,n):function(t,e,r){const n=Ut;if(!Z(r,n,t.spatialReference)){const e=t.origin;n[0]=e.x,n[1]=e.y,n[2]=e.z,bt.error(`Failed to project specified origin (wkid:${r.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}).`)}kt(t.vertexAttributes.position,e,3,n),kt(t.vertexAttributes.normal,e,3),kt(t.vertexAttributes.tangent,e,4),t.vertexAttributesChanged()}(t,e,n)}}function kt(t,e,r,n=j){if(!i(t)){rt(Pt,L(e),z(e));for(let e=0;e<t.length;e+=r){for(let r=0;r<3;r++)Mt[r]=t[e+r]-n[r];b(Mt,Mt,Pt);for(let r=0;r<3;r++)t[e+r]=Mt[r]+n[r]}}}const Mt=g(),Rt=g(),Ft=O(),Pt=_(),Ot=W(),Ut=g(),zt=o.getLogger("esri.geometry.support.meshUtils.scale");function Lt(t,e,r){if(!t.vertexAttributes||!t.vertexAttributes.position)return;const n=t.spatialReference;if(s(t.transform)){var o;null!=(null==r?void 0:r.geographic)&&r.geographic!==t.transform.geographic&&zt.warn(`Specifying the 'geographic' parameter (${r.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`);const s=null!=(o=null==r?void 0:r.origin)?o:t.transform.getOriginPoint(n);!function(t,e,r){const n=y(St,r.x,r.y,r.z),o=w(St,n,t.origin);t.applyLocalInverse(o,$t);const s=A(g(),t.scale,e);t.scale=s,t.applyLocalInverse(o,o),w(o,o,$t),t.translation=d(g(),t.translation,o)}(t.transform,e,s)}else{const n=T(t.spatialReference,r),o=r&&r.origin||t.origin;n?function(t,e,r){const n=t.spatialReference,o=J(n),i=Tt;Z(r,i,o)||Z(t.origin,i,o);const a=t.vertexAttributes.position,c=t.vertexAttributes.normal,l=t.vertexAttributes.tangent,p=new Float64Array(a.length),u=s(c)?new Float32Array(c.length):null,h=s(l)?new Float32Array(l.length):null;K(a,n,p),s(c)&&Q(c,a,p,n,u);s(l)&&X(l,a,p,n,h);Ct(p,e,i),Y(p,a,n),s(c)&&tt(u,a,p,n,c);s(l)&&et(h,a,p,n,l);t.vertexAttributesChanged()}(t,e,o):function(t,e,r){const n=Tt;if(!Z(r,n,t.spatialReference)){const e=t.origin;n[0]=e.x,n[1]=e.y,n[2]=e.z,zt.error(`Failed to project specified origin (wkid:${r.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}).`)}Ct(t.vertexAttributes.position,e,n),t.vertexAttributesChanged()}(t,e,o)}}function Ct(t,e,r=j){if(t)for(let n=0;n<t.length;n+=3){for(let e=0;e<3;e++)St[e]=t[n+e]-r[e];A(St,St,e);for(let e=0;e<3;e++)t[n+e]=St[e]+r[e]}}const St=g(),$t=g(),Tt=g();var It;const Bt=o.getLogger("esri.geometry.Mesh");let Et=It=class extends(r(n.LoadableMixin(a(R)))){constructor(t){super(t),this.components=null,this.transform=null,this.external=null,this.hasZ=!0,this.hasM=!1,this.vertexAttributes=new $,this.type="mesh"}initialize(){(i(this.external)||this.vertexAttributes.position.length)&&(this.loadStatus="loaded"),this.when((()=>{this.handles.add(h((()=>{var t;return{vertexAttributes:this.vertexAttributes,components:null==(t=this.components)?void 0:t.map((t=>t.clone())),transform:s(this.transform)?this.transform.clone():null}}),(()=>this._set("external",null)),{once:!0,sync:!0}))}))}get hasExtent(){return!this.loaded&&s(this.external)&&s(this.external.extent)||this.loaded&&this.vertexAttributes.position.length>0&&(!this.components||this.components.length>0)}get boundingInfo(){const t=this.vertexAttributes.position,e=this.spatialReference;if(0===t.length||this.components&&0===this.components.length)return{extent:new M({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0,spatialReference:e}),center:new F({x:0,y:0,z:0,spatialReference:e})};const r=s(this.transform)?this.transform.project(t,e):t;let n=1/0,o=1/0,i=1/0,a=-1/0,c=-1/0,l=-1/0,p=0,u=0,h=0;const f=r.length,m=1/(f/3);let g=0;for(;g<f;){const t=r[g++],e=r[g++],s=r[g++];n=Math.min(n,t),o=Math.min(o,e),i=Math.min(i,s),a=Math.max(a,t),c=Math.max(c,e),l=Math.max(l,s),p+=m*t,u+=m*e,h+=m*s}return{extent:new M({xmin:n,ymin:o,zmin:i,xmax:a,ymax:c,zmax:l,spatialReference:e}),center:new F({x:p,y:u,z:h,spatialReference:e})}}get anchor(){if(s(this.transform))return this.transform.getOriginPoint(this.spatialReference);const t=this.boundingInfo;return new F({x:t.center.x,y:t.center.y,z:t.extent.zmin,spatialReference:this.spatialReference})}get origin(){return s(this.transform)?this.transform.getOriginPoint(this.spatialReference):this.boundingInfo.center}get extent(){return!this.loaded&&s(this.external)&&s(this.external.extent)?this.external.extent.clone():this.boundingInfo.extent}addComponent(t){this.loaded?(this.components||(this.components=[]),this.components.push(S.from(t)),this.notifyChange("components")):Bt.error("addComponent()","Mesh must be loaded before applying operations")}removeComponent(t){if(this.loaded){if(this.components){const e=this.components.indexOf(t);if(-1!==e)return this.components.splice(e,1),void this.notifyChange("components")}Bt.error("removeComponent()","Provided component is not part of the list of components")}else Bt.error("removeComponent()","Mesh must be loaded before applying operations")}rotate(t,e,r,n){return C(Gt.x,t,qt),C(Gt.y,e,Zt),C(Gt.z,r,Dt),U(qt,Zt,qt),U(qt,Dt,qt),At(this,qt,n),this}offset(t,e,r,n){return this.loaded?(Vt[0]=t,Vt[1]=e,Vt[2]=r,ut(this,Vt,n),this):(Bt.error("offset()","Mesh must be loaded before applying operations"),this)}scale(t,e){return this.loaded?(Lt(this,t,e),this):(Bt.error("scale()","Mesh must be loaded before applying operations"),this)}centerAt(t,e){return this.loaded?(ot(this,t,e),this):(Bt.error("centerAt()","Mesh must be loaded before applying operations"),this)}load(t){return s(this.external)&&this.addResolvingPromise(async function(t,e,r){const{loadGLTFMesh:n}=await c(import("../chunks/loadGLTFMesh.js"),r),o=await ct(e,r),i=n(new F({x:0,y:0,z:0,spatialReference:t.spatialReference}),o.url,{resolveFile:at(o),useTransform:!0,signal:s(r)?r.signal:null});i.then((()=>o.dispose()),(()=>o.dispose()));const{vertexAttributes:a,components:l}=await i;t.vertexAttributes=a,t.components=l}(this,this.external.source,t)),Promise.resolve(this)}clone(){const t=this.components?new Map:null,e=this.components?new Map:null,r={components:this.components?this.components.map((r=>r.cloneWithDeduplication(t,e))):null,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes.clone(),transform:s(this.transform)?this.transform.clone():null,external:s(this.external)?{source:this.external.source,extent:s(this.external.extent)?this.external.extent.clone():null}:null};return new It(r)}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}async toBinaryGLTF(t){const{toBinaryGLTF:e}=await import("../chunks/gltfexport.js");return e(this,t)}static createBox(t,e){if(!(t instanceof F))return Bt.error(".createBox()","expected location to be a Point instance"),null;const r=new It(xt(function(){const{faceDescriptions:t,faceVertexOffsets:e,uvScales:r}=vt,n=4*t.length,o=new Float64Array(3*n),s=new Float32Array(3*n),i=new Float32Array(2*n),a=new Uint32Array(2*t.length*3);let c=0,l=0,p=0,u=0;for(let n=0;n<t.length;n++){const h=t[n],f=c/3;for(const t of e)a[u++]=f+t;const m=h.corners;for(let t=0;t<4;t++){const e=m[t];let n=0;i[p++]=.25*r[t][0]+h.uvOrigin[0],i[p++]=h.uvOrigin[1]-.25*r[t][1];for(let t=0;t<3;t++)0!==h.axis[t]?(o[c++]=.5*h.axis[t],s[l++]=h.axis[t]):(o[c++]=.5*e[n++],s[l++]=0)}}return{position:o,normal:s,uv:i,faces:a}}(),t,e));return e&&e.imageFace&&"all"!==e.imageFace?function(t,e){const r=t.components[0],n=r.faces,o=yt[e],i=6*o,a=new Uint32Array(6),c=new Uint32Array(n.length-6);let l=0,p=0;for(let t=0;t<n.length;t++)t>=i&&t<i+6?a[l++]=n[t]:c[p++]=n[t];if(s(t.vertexAttributes.uv)){const e=new Float32Array(t.vertexAttributes.uv),r=4*o*2,n=[0,1,1,1,1,0,0,0];for(let t=0;t<n.length;t++)e[r+t]=n[t];t.vertexAttributes.uv=e}return t.components=[new S({faces:a,material:r.material}),new S({faces:c})],t}(r,e.imageFace):r}static createSphere(t,e){return t instanceof F?new It(xt(function(t=0){const e=Math.round(8*2**t),r=2*e,n=(e-1)*(r+1)+2*r,o=new Float64Array(3*n),s=new Float32Array(3*n),i=new Float32Array(2*n),a=new Uint32Array((e-1)*r*2*3);let c=0,l=0,p=0,u=0;for(let t=0;t<=e;t++){const n=t/e*Math.PI+.5*Math.PI,h=Math.cos(n),f=Math.sin(n);wt[2]=f;const m=0===t||t===e,g=m?r-1:r;for(let n=0;n<=g;n++){const f=n/g*2*Math.PI;wt[0]=-Math.sin(f)*h,wt[1]=Math.cos(f)*h;for(let t=0;t<3;t++)o[c]=.5*wt[t],s[c]=wt[t],++c;i[l++]=(n+(m?.5:0))/r,i[l++]=t/e,0!==t&&n!==r&&(t!==e&&(a[p++]=u,a[p++]=u+1,a[p++]=u-r),1!==t&&(a[p++]=u,a[p++]=u-r,a[p++]=u-r-1)),u++}}return{position:o,normal:s,uv:i,faces:a}}(e&&e.densificationFactor||0),t,e)):(Bt.error(".createSphere()","expected location to be a Point instance"),null)}static createCylinder(t,e){return t instanceof F?new It(xt(function(t=0){const e=Math.round(16*2**t),r=4*(e+1)+2*e,n=new Float64Array(3*r),o=new Float32Array(3*r),s=new Float32Array(2*r),i=new Uint32Array(4*e*3);let a=0,c=0,l=0,p=0,u=0;for(let t=0;t<=5;t++){const r=0===t||5===t,h=t<=1||t>=4,f=2===t||4===t,m=r?e-1:e;for(let g=0;g<=m;g++){const d=g/m*2*Math.PI,x=r?0:.5;wt[0]=x*Math.sin(d),wt[1]=x*-Math.cos(d),wt[2]=t<=2?.5:-.5;for(let e=0;e<3;e++)n[a++]=wt[e],o[c++]=h?2===e?t<=1?1:-1:0:2===e?0:wt[e]/x;s[l++]=(g+(r?.5:0))/e,s[l++]=t<=1?1*t/3:t<=3?1*(t-2)/3+1/3:1*(t-4)/3+2/3,f||0===t||g===e||(5!==t&&(i[p++]=u,i[p++]=u+1,i[p++]=u-e),1!==t&&(i[p++]=u,i[p++]=u-e,i[p++]=u-e-1)),u++}}return{position:n,normal:o,uv:s,faces:i}}(e&&e.densificationFactor||0),t,e)):(Bt.error(".createCylinder()","expected location to be a Point instance"),null)}static createPlane(t,e){var r;if(!(t instanceof F))return Bt.error(".createPlane()","expected location to be a Point instance"),null;const n=null!=(r=null==e?void 0:e.facing)?r:"up",o=function(t,e){const r="number"==typeof e?e:null!=e?e.width:1,n="number"==typeof e?e:null!=e?e.height:1;switch(t){case"up":case"down":return{width:r,depth:n};case"north":case"south":return{width:r,height:n};case"east":case"west":return{depth:r,height:n}}}(n,null==e?void 0:e.size);return new It(xt(function(t){const e=dt.facingAxisOrderSwap[t],r=dt.position,n=dt.normal,o=new Float64Array(r.length),s=new Float32Array(n.length);let i=0;for(let t=0;t<4;t++){const t=i;for(let a=0;a<3;a++){const c=e[a],l=Math.abs(c)-1,p=c>=0?1:-1;o[i]=r[t+l]*p,s[i]=n[t+l]*p,i++}}return{position:o,normal:s,uv:new Float32Array(dt.uv),faces:new Uint32Array(dt.faces)}}(n),t,{...e,size:o}))}static createFromPolygon(t,e){if(!(t instanceof P))return Bt.error(".createFromPolygon()","expected polygon to be a Polygon instance"),null;const r=q(t);return new It({vertexAttributes:new $({position:r.position}),components:[new S({faces:r.faces,shading:"flat",material:e&&e.material||null})],spatialReference:t.spatialReference})}static async createFromGLTF(t,r,n){if(!(t instanceof F))throw Bt.error(".createfromGLTF()","expected location to be a Point instance"),new e("invalid-input","Expected location to be a Point instance");const{loadGLTFMesh:o}=await c(import("../chunks/loadGLTFMesh.js"),n);return new It(await o(t,r,n))}static createWithExternalSource(t,e,r){var n,o,s;const i=null!=(n=null==r?void 0:r.extent)?n:null,a=null!=(o=null==r?void 0:r.transform.clone())?o:new G;a.origin=[t.x,t.y,null!=(s=t.z)?s:0];const c=t.spatialReference;return new It({external:{source:e,extent:i},transform:a,spatialReference:c})}static createIncomplete(t,r){var n,o;const s=null!=(n=null==r?void 0:r.transform.clone())?n:new G;s.origin=[t.x,t.y,null!=(o=t.z)?o:0];const i=t.spatialReference,a=new It({transform:s,spatialReference:i});return a.addResolvingPromise(Promise.reject(new e("mesh-incomplete","Mesh resources are not complete"))),a}};t([f({type:[S],json:{write:!0}})],Et.prototype,"components",void 0),t([f({type:G,json:{write:!0}})],Et.prototype,"transform",void 0),t([f({constructOnly:!0})],Et.prototype,"external",void 0),t([f({readOnly:!0})],Et.prototype,"hasExtent",null),t([f({readOnly:!0})],Et.prototype,"boundingInfo",null),t([f({readOnly:!0})],Et.prototype,"anchor",null),t([f({readOnly:!0})],Et.prototype,"origin",null),t([f({readOnly:!0,json:{read:!1}})],Et.prototype,"extent",null),t([f({readOnly:!0,json:{read:!1,write:!0,default:!0}})],Et.prototype,"hasZ",void 0),t([f({readOnly:!0,json:{read:!1,write:!0,default:!1}})],Et.prototype,"hasM",void 0),t([f({type:$,nonNullable:!0,json:{write:!0}})],Et.prototype,"vertexAttributes",void 0),Et=It=t([m("esri.geometry.Mesh")],Et);const Gt={x:k(1,0,0),y:k(0,1,0),z:k(0,0,1)},qt=O(),Zt=O(),Dt=O(),Vt=g(),Ht=Et;export{Ht as default};
